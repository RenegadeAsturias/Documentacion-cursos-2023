
Curso Profesional de Angular (Código Facilito) (19/04/2023)

Temario:

Módulo-01-Introducción-Clase-01-Presentación del curso
Módulo-01-Introducción-Clase-02-Qué aprenderás y requisitos previos
Módulo-01-Introducción-Clase-03-Qué es y qué podemos hacer con Angular

Módulo-02-EntornoTrabajo-Clase-01-Instalando Angular
Módulo-02-EntornoTrabajo-Clase-02-Instalando VSCode y Extensiones
Módulo-02-EntornoTrabajo-Clase-03-Explorando el Angular CLI
Módulo-02-EntornoTrabajo-Clase-04-Estructura proyecto Angular

Módulo-03-Componentes-Clase-01-Qué es un componente
Módulo-03-Componentes-Clase-02-Creando un componente

Módulo-04-Directivas-Clase-01-Qué son las directivas
Módulo-04-Directivas-Clase-02-Directivas de atributo
Módulo-04-Directivas-Clase-03-Directivas estructurales

Módulo-05-Pipes-Clase-01-Qué son los pipes 
Módulo-05-Pipes-Clase-02-Creando nuestro Pipe -Pipe Vs Funciones

Módulo-06-Rutas-Clase-01-Qué son los módulos
Módulo-06-Rutas-Clase-02-Rutas
Módulo-06-Rutas-Clase-03-Rutas con hijos
Módulo-06-Rutas-Clase-04-Guards
Módulo-06-Rutas-Clase-05-Aplicando lazy loading en rutas

Módulo-07-Forms-Clase-01-Forms-FormControl
Módulo-07-Forms-Clase-02-FormGroups

Módulo-08-Forms-Clase-01-Arquitectura de servicios en Angular
Módulo-08-Forms-Clase-02-Servicios en Angular (petición get)
Módulo-08-Forms-Clase-03-HTTP-Petición GET con params
Módulo-08-Forms-Clase-04-HTTP-Petición POST,PUT,DELETE
Módulo-08-Forms-Clase-05-HTTP-Interceptores

Módulo-09-RxJS-Clase-01-Introducción a RxJS
Módulo-09-RxJS-Clase-02-RxJS-Casos prácticos
Módulo-09-RxJS-Clase-03-RxJS-Operadores

Módulo-10-ProyectoFinal-Clase-01-Demostración del proyecto final
Módulo-10-ProyectoFinal-Clase-02-Estructura del proyecto
Módulo-10-ProyectoFinal-Clase-03-Wireframes del proyecto
Módulo-10-ProyectoFinal-Clase-04-Listado-Creando los componentes
Módulo-10-ProyectoFinal-Clase-05-Listado-Funcionalidad del listado
Módulo-10-ProyectoFinal-Clase-06-Listado-Agregando scroll infinito
Módulo-10-ProyectoFinal-Clase-07-Listado-Agregando filtrado
Módulo-10-ProyectoFinal-Clase-08-Detalle-Creando los componentes
Módulo-10-ProyectoFinal-Clase-09-Detalle-Funcionalidad

******************************************************************************
******************************************************************************

Curso Profesional de Angular (Código Facilito) (19/04/2023)

$ ng new 0012-curso-profesional-angular

***************************************** COMPONENTES:
$ cd 0012-curso-profesional-angular
$ ng g c directiva-atributo
$ ng g c directiva-estructural
$ ng serve -o


git add .
git commit -m "Curso Profesional de Angular (Código Facilito) (19/04/2023). Inicio"

--Crear el repositorio en GitHub
git remote add origin https://github.com/RenegadeAsturias/0012-curso-profesional-angular.git
git push origin main

***************************************** PIPES:
$ ng g c pipes

Documentación de pipes:
https://angular.io/guide/pipes
https://angular.io/api/common/DatePipe

$ ng g pipe pipes/estados


***************************************** RUTAS:
(1) ¿Qué son los módulos?
Agrupación de componentes por funcionalidad.

(2) Rutas
(3) Rutas con hijos
(4) Guards
(5) Aplicando lazy loading en rutas

$ ng g m compra

#¡Ojo! Para que me añada los nuevos componentes
#al módulo 'compra' (ej:UPDATE src/app/compra/compra.module.ts)
$ cd src/app/compra

$ ng g c listado
CREATE src/app/compra/listado/listado.component.html (22 bytes)
CREATE src/app/compra/listado/listado.component.spec.ts (606 bytes)
CREATE src/app/compra/listado/listado.component.ts (206 bytes)
CREATE src/app/compra/listado/listado.component.css (0 bytes)
UPDATE src/app/compra/compra.module.ts (278 bytes)

$ ng g c nuevaCompra
$ ng g c historialCompra

@NgModule({
  declarations: [
    ListadoComponent, ************** Componente 'listado' actualizado
    NuevaCompraComponent, ********** Componente 'nuevaCompra' actualizado
    HistorialCompraComponent ******* Componente 'historialCompra' actualizado
  ],
  imports: [
    CommonModule
  ]
})
export class CompraModule { }


************************************************************
#Ahora quiero utilizar uno de mis nuevos componentes del módulo 'compra'
#Y en 'app.component.html' añado el selector: 'app-listado',

<h1>Listado de Compras</h1>
<app-listado></app-listado>

#Pero el compilador me da error
'app-listado' is not a known element:
1. If 'app-listado' is an Angular component, then verify that it is part of this module.

#Aún no puedo utilizar el módulo 'compra' tengo que registrarlo en:
scr > app > app.module.ts

@NgModule({
  declarations: [
    AppComponent,
    DirectivaAtributoComponent,
    DirectivaEstructuralComponent,
    PipesComponent,
    EstadosPipe
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    CompraModule ******************* Módulo 'compra' registrado
  ],
... ... ... ...

#El error persiste:
'app-listado' is not a known element:
1. If 'app-listado' is an Angular component, then verify that it is part of this module.

#Los Componentes están registrados en el módulo 'compra'
#pero son propios de este módulo y por defecto
#otros módulos no pueden utilizarlos como en este caso
#porque puede ser que en realidad queramos eso, que nuestros componentes
#sólo deben ser vistos por un componente y no sean vistos por el resto de módulos.
#Para solucionarlo, en el módulo 'compra' hay que exportar
#los componentes que pueden ser vistos por otros módulos:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],
  exports: [
    ListadoComponent  ********* Exportar los componentes
                      ********* visibles para otros módulos
  ],
  imports: [
    CommonModule
  ]
})
export class CompraModule { }

#Ahora ya funciona correctamente la llamada al componente:
<h1>Listado de Compras</h1>
<app-listado></app-listado>
√ Compiled successfully.


#Entonces como el componente del módulo 'compra': NuevaCompraComponent
#no ha sido exportado no podría hacer:
src > app > app.component.html
<h1>Nueva Compra</h1>
<app-nueva-compra></app-nueva-compra>

#Pero si podría utilizarlo dentro de los componentes
#correspondientes al módulo 'compra'.
#Esto funciona:
src > app > compra > listado > listado.component.html
<h1>Nueva Compra</h1>
<app-nueva-compra></app-nueva-compra>

******************************************************************
Creamos un nuevo módulo que va a trabajar con la ruta de nuestro proyecto:
$ ng g m AppRouting
CREATE src/app/app-routing/app-routing.module.ts

Como yo ya había creado el proyecto y le dije que habilitase Routing Y
ya tengo creado el módulo para las rutas en:

src > app > app-routing.module.ts

Tendremos esto:

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

------------------------------------------------------------

#Añadimos las rutas en:
const routes: Routes = [
    {path: 'pipes', PipesComponent: }
];

Para que funcione, tecleamos en la url del navegador
http://localhost:4200/pipes

Pero aún no se muestra nada, nos vamos:

src > app > app.component.hml

Comentamos todo lo que teníamos y añadimos:

<router-outlet></router-outlet>

ahora volvemos a escribir:
src > app > app.component.hml

Y ya vemos el contenido de nuestro componente:
scr > app > pipes > pipes.component.html
desplegado en el contenedor:
<router-outlet></router-outlet>

Pipe titlecase: René
Pipe upppercase: RENÉ
Pipe date: Feb 20, 2020

------------------------------------------------------------

#Añadimos otra ruta en:
const routes: Routes = [
  {path: 'pipes', component: PipesComponent},
  {path: 'estructural', component: DirectivaEstructuralComponent}
];

Para que funcione, tecleamos en la url del navegador
http://localhost:4200/esctructural

------------------------------------------------------------

Vamos a implementar un botón para ir
desde la página de Pipes para ir a Estructural:

<button [routerLink]="['/estructural']">Ir a Componente Estructural</button>

Y ahora añadimos otro nuevo botón
y vemos el atributo: routerLinkActive
que nos ayuda a identificar la ruta activa
y le asociamos un estilo para que se identifique que estamos en ella.

<button [routerLink]="['/estructural']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<button [routerLink]="['/pipes']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>

------------------------------------------------------------

Cambimos de lugar los botones de cambios de rutas para que nos sirvan
en modo navegación, en:

src > app > app.component.html

<button [routerLink]="['/estructural']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<button [routerLink]="['/pipes']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<router-outlet></router-outlet>


------------------------------------------------------------

Rutas con hijos:

1.-En el módulo de compras tenemos declaradas los siguientes componentes:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],

Y vamos a seleccionar el: ListadoComponent 
como el contenedor de todo el módulo de compras:

Así que voy a añadir la ruta padre con: ListadoComponent
y las rutas hijas con el resto de componentes.
De momento tenemos solo estas rutas definidas:

const routes: Routes = [
  {path: 'pipes', component: PipesComponent},
  {path: 'estructural', component: DirectivaEstructuralComponent}
];

Añadimos las rutas:
const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', component: ListadoComponent, children: [
		{ path: 'nueva', component: NuevaCompraComponent },
		{ path: 'historial', component: HistorialCompraComponent },
	]}
];

Para poder utilizar las Rutas en nuestro módulo de compras
tenemos que añadir el 'RouterModule' al módulo:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],
  exports: [
    ListadoComponent
  ],
  imports: [
    CommonModule,
	RouterModule ************** Para poder utilizar las rutas en el módulo de compras
  ]
})
export class CompraModule { }

Ahora vamos a configurar una navegación para nuestro módulo de compras:

src > app > compra > listado.component.html

<button [routerLink]="['/compra/nueva']" routerLinkActive="seccionActiva">Nueva compra</button>
<button [routerLink]="['/compra/historial']" routerLinkActive="seccionActiva">Historial compra</button>
<router-outlet></router-outlet>


------------------------------------------------------------
--------------- Ruta por defecto ---------------------------

Configuramos la Ruta por defecto para cuando no haya una ruta
por ejemplo, cuando entramos inicialmente en la aplicación

http://localhost:4200

Añadimos la ruta:
const routes: Routes = [
	... ... ... ... ..., 
	{ path: '', redirectTo: 'pipes', pathMatch: 'full' }
];

De esta forma cuando introduccimos en la Url del navegador:
http://localhost:4200

Nos redirecciona a:
http://localhost:4200/pipes


------------------------------------------------------------
--------------- Guards -------------------------------------

Comenzamos a ver Guards
que son filtros o funciones que podemos añadir a una ruta para que
por ejemplo se valide algo antes de acceder a la ruta:

$ ng g guard auth

Y el menú de opciones nos solicita que tipo de Guard queremos crear:

$ ng g guard auth
? Which type of guard would you like to create? (Press <space> to select, <a> to toggle all, <i> to invert selection, and
<enter> to proceed)
>(*) CanActivate
 ( ) CanActivateChild
 ( ) CanDeactivate
 ( ) CanLoad
 ( ) CanMatch

Selecciono el valor por defecto:
>(*) CanActivate

Y nos crea estos dos ficheros:
CREATE src/app/auth.guard.spec.ts (331 bytes) ******* Para pruebas
CREATE src/app/auth.guard.ts (457 bytes) ************ Para la lógica que verifica si puedo acceder

que nos permite saber si podemos acceder a una ruta.

Los guards no se actualizan dentro de ningún módulo
ni necesitan estar dentro de ningún módulo.

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
	
	// Debajo de los dos parámetros que recibe el método
	// Introducimos la lógica de negocio que verifica si accedemos o no
	// Como valor devuelto más típico, devolvemos un booleano.
	
    return true;
  }
  
}

Para un ejemplo, simulando una autenticación definimos en:

src > app > app.component.ts

export class AppComponent {

	constructor() { // Simulamos el Id del usuario.
		localStorage.setItem('id', '1234');
	}

Y ahora implementamos la comprobación en nuestro Guard auth:

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
	
	const id = localStorage.getItem('id');
    return id === '1234';
  }
  
}

De momento solo lo hemos definido pero no lo hemos utilizado.
Vamos a nuestro módulo de rutas:

src > app > app-routing.module.ts

Y lo anexado a la ruta que deseamos proteger:

La ruta que deseamos proteger en este caso es 'compra'
Le añadimos un atributo nuevo: canActivate
y como valores le asignamos un array con los Guards
que quiero que anexar a la ruta.

Añadimos los Guards a la ruta:

import { AuthGuard } from './auth.guard';

const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard], ****************** Guard anexado
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard],
		children: [
			{ path: 'nueva', component: NuevaCompraComponent },
			{ path: 'historial', component: HistorialCompraComponent },
		]
	}
];

Para probar que funciona añadimos un nuevo botón a nuestra cabecera de navegación:

src > app > app.component.html

<button [routerLink]="['/compra']" routerLinkActive="seccionActiva">Ir a Compras</button>

Y hacemos clic en el botón 'Ir a Compras' y vemos que nos lleva correctamente
a la ruta '/compras' que habíamos protegido con nuestro Guard
porque el identificador del usuario de la validación coincide con '1234'
y el Guard está pasando como true.


Ahora vamos a guardar inicialmente otro identificador diferente
en el localStorage para que el Guard no valide la condicón a true:

src > app > app.component.ts

export class AppComponent {

	constructor() { // Simulamos el Id del usuario.
		localStorage.setItem('id', '9999');
	}
	

-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-06-Rutas-Clase-05-Aplicando lazy loading en rutas

Hemos estado trabajando con rutas en el módulo anterior
y tenemos un montón de rutas definidas en nuestro proyecto.
y eso está bastante bien pero lo que pasa con las Single Page Application (SPA)
es que solo cargan una vez todos los módulos 
y después el usuario puede recorrer entre ellos sin necesidad
de que la página se recargue.

El problema puede surgir si nuestra aplicación tiene
muchas páginas, muchas rutas y muchos módulos
la carga inicial de nuestra aplicación puede ser un poco lenta.
Así que dependiendo del número de módulos de nuestra aplicación
en algún punto no es viable está cargando todo en el inicio.

Porque en la mayoría de los casos los usuarios no van a utilizar
todas las rutas que tenemos definidas en nuestro proyecto.
Por lo que no sirve de nada relentizar la carga inicial de la página
por cargar módulos que el usuario no va a utilizar.

La solución para este problema se llama: lazy loading
es decir, carga perezosa que es una estrategia para descargar
de manera perezosa o en otras palabras a demanda
algunos módulos que nosotros queramos cargar así.

Por ejemplo, si nuestra aplicación tiene 10 módulos
pero los que más utilizan todos los usuarios son dos
los podemos cargar en el inicio de la aplicación
y los demás van a cargar cuando el usuario intente entrar
en la ruta de cada módulo.

De este modo la carga inicial será más rápida
y cuando usuario intenté entrar a la ruta de un módulo no cargaddo
se va a descargar toda la lógica de este módulo.

Vamos a crear en nuestra aplicación de ejemplo
un nuevo módulo de venta y que tenga lazy loading implementado.

Creamos el módulo de venta:
$ ng g m venta --routing=true

CREATE src/app/venta/venta-routing.module.ts (248 bytes)
CREATE src/app/venta/venta.module.ts (276 bytes)

Nos crea un fichero extra, para manejar las rutas de nuestro
nuevo módulo de manera encapsulada:

src/app/venta/venta-routing.module.ts

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class VentaRoutingModule { }


---------- Añadimos unos componentes para nuestro módulo de venta -----------
con el mismo nombre que nuestros componentes del módulo de compra
pero que estén dentro de la carpeta 'venta'

$ ng g c venta/listado
CREATE src/app/venta/listado/listado.component.html (22 bytes)
CREATE src/app/venta/listado/listado.component.spec.ts (606 bytes)
CREATE src/app/venta/listado/listado.component.ts (206 bytes)
CREATE src/app/venta/listado/listado.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (364 bytes)

$ ng g c venta/historial-venta
CREATE src/app/venta/historial-venta/historial-venta.component.html (30 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.spec.ts (656 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.ts (237 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (480 bytes)

$ ng g c venta/nueva-venta
CREATE src/app/venta/nueva-venta/nueva-venta.component.html (26 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.spec.ts (628 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.ts (221 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (580 bytes)


En nuestro nuevo módulo de ventas, añadimos las nuevas rutas:

src > app > venta > venta-routing.module.ts

import { NuevaVentaComponent } from './nueva-venta/nueva-venta.component';
import { HistorialVentaComponent } from './historial-venta/historial-venta.component';

const routes: Routes = [{
	path: '',
	children: [
		{ path: '', redirectTo: 'nueva', pathMatch: 'full' },
		{ path: 'nueva', component: NuevaVentaComponent },
		{ path: 'historial', component: HistorialVentaComponent },
	],
}];
	
Hemos creado un nuevo módulo y tenemos que añadirlo al fichero:

src > app > app.module.ts

import { VentaModule } from './venta/venta.module';

@NgModule({
  declarations: [
    AppComponent,
	... ... ... ...
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    CompraModule,
    VentaModule ************ Incluimos en nuevo módulo venta   
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

Anora vamos a añadir una nueva ruta pero en nuestro fichero:

src > app > app-routing.module.ts

const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard],
		children: [
			{ path: 'nueva', component: NuevaCompraComponent },
			{ path: 'historial', component: HistorialCompraComponent },
		]
	},
	{ path: 'venta', ********************* Nueva Ruta
		loadChildren: () => 
			import('./venta/venta.module').then((m) => m.VentaModule),
	},
];

Para que se carguen el módulo de venta tendremos que ir a la url
del navegador e introducir: http://localhost:4200/venta

Desde las herramientas de desarrollo del Chrome vemos como ahora
se descarga el módulo de venta.


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-07-Forms-Clase-01-Forms-FormControl

Creando y gestionando formularios con Angular
Existen dos tipos de manejos de formularios:
-Formuarios por template
-Formularios reactivos

Creamos un nuevo repositorio para ver los formularios

$ ng new 0014-curso-profesional-angular-formularios

Creamos un nuevo componente:
(con --skip-test no se creará el fichero de test)

Creamos un componente para crear formularios reactivos
$ ng g c formularios --skip-tests

Y también creamos un nuevo componente para crear botones
de navegación:
$ ng g c cabecera --skip-tests

#Añadimos la ruta para el componente formularios en:
const routes: Routes = [
	{ path: '', redirectTo: 'formularios', pathMatch: 'full' }
    { path: '/formularios', component: FormulariosComponent  }
];

Pero aún no se muestra nada, nos vamos a:
src > app > app.component.hml

Y añadimos
<app-cabecera></app-cabecera>
<router-outlet></router-outlet>

En el template del componente cabecera añadimos al menos un botón:
<button [routerLink]="['/formularios']" routerLinkActive="seccionActiva">Ir a Formularios</button>
<hr>

Para poder utilizar los formularios reactivos añadimos el módulo: ReactiveFormsModule en:

scr > app > app.module.ts

Añadimos:

import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  declarations: [
    AppComponent,
    CabeceraComponent,
    FormulariosComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    ReactiveFormsModule ******** Formularios Reactivos


Ahora vamos a añadir un control que estará asociado o tendrá un binding
a una varible del formulario:

scr > app > formularios > formularios.component.ts

import { FormControl } from '@angular/forms';

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('');
}

scr > app > formularios > formularios.component.html

<input type="text" placeholder="Nombre" [formControl]="name">
{{name.value}} // Incluímos una interpolación para ver el valor de la variable del input

+Añadimos otro campo:

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('');
  isChecked = new FormControl(false);
}

<input type="checkbox" [formControl]="isChecked"/>
{{isChecked.value}}

Para visualizar un objeto y sus propiedades por pantalla
por ejemplo para depuración podemos escribir:

<pre>
	<code>
		{{isChecked | json}}
	</code>
</pre>

------------- Añadimos Validators ----------------------------------

Por ejemplo, añadimos Validators al campo name:

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('', [Validators.minLength(4), Validators.required]);

Y también añadimos en el template la sintaxis anterior para ver el objeto
y las validaciones y sus estados cuando utilizamos el campo:

<pre>
	<code>
		{{name | json}}
	</code>
</pre>

Ahora vamos a añadir un nuevo botón que esté deshabilido si hay errores
en el campo nombre y habilitado si no hay errores:

<button [disabled]="name.errors">Enviar</button>


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-07-Forms-Clase-02-FormsGroups

FormsGroups es un objeto que nos permite manejar varios FormsControl.

Por ejemplo, para crear un FormGroup con los FormsControl
del ejemplo anterior sería:

form = new FormGroup({
    name: new FormControl('', [Validators.minLength(4), Validators.required]),
    isChecked: new FormControl(false)
});

Para completar el template utilizando FormGroups:

<form [formGroup]="form">
  <div class="">
      <input type="text" placeholder="Nombre" formControlName="name">
      <br/>{{form.get('name')?.value}}
  </div>
  <hr>
  <div class="">
      <input type="checkbox" formControlName="isChecked"/>
      <br/>{{form.get('isChecked')?.value}}
  </div>
</form>
<br/>
<button [disabled]="form.get('name')?.errors">Enviar</button>

<br/><br/><hr>
Para visualizar el formulario:
<br/>
{{form.value | json}}


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-08-Forms-Clase-01-Arquitectura de servicios en Angular

+Utilizar y consumir servicios HTTP:

Diagrama: App Angular <--(json)-> API REST <---> SERVIDOR

App Angular:
[Componentes <---> Servicios] <--(json)-> API REST <---> SERVIDOR


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-08-Forms-Clase-02-Servicios en Angular (petición get)

API REST que consumiremos: https://jsonplaceholder.typicode.com/todos

[
  {
    "userId": 1,
    "id": 1,
    "title": "delectus aut autem",
    "completed": false
  },
  {
    "userId": 1,
    "id": 2,
    "title": "quis ut nam facilis et officia qui",
    "completed": false
  },
  {
    "userId": 1,
    "id": 3,
    "title": "fugiat veniam minus",
    "completed": false
  },
... ... ... ... ... ... ... ... ... ... ... ... 

Creamos un nuevo componente:

$ ng g c todos
CREATE src/app/todos/todos.component.html (20 bytes)
CREATE src/app/todos/todos.component.spec.ts (592 bytes)
CREATE src/app/todos/todos.component.ts (198 bytes)
CREATE src/app/todos/todos.component.css (0 bytes)
UPDATE src/app/app.module.ts (848 bytes)

y dentro de la carpeta, creamos un servicio:

$ cd src/app/todos
$ ng g s todo
CREATE src/app/todos/todo.service.spec.ts (347 bytes)
CREATE src/app/todos/todo.service.ts (133 bytes)


Se ha creado el servicio: 'todo.service'

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' ********* Con esta propiedad declarada se habilita en Angular
					 ********* que todos los componentes puedan hacer uso de un Servicio
})
export class TodoService {

  constructor() { }
}


Si la propiedad providedIn: 'root' no está declarada
para utilizar un Servicio en un módulo habría que añadirlo.
En nuestra aplicación simple de formularios solo tenemos:

src > app > app.module.ts

@NgModule({
  declarations: [
    AppComponent,
    CabeceraComponent,
    FormulariosComponent,
    Formularios2Component,
    TodosComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    ReactiveFormsModule
  ],
  providers: [TodoService], ******** Añadimos el Servicio.
  bootstrap: [AppComponent]
})
export class AppModule { }


Si la aplicación tuviese diferentes módulos añadiríamos
el Servicio al módulo o módulos desde los que deseamos utilizar el servicio:

Ejemplo:
src > app > venta > venta.module.ts

@NgModule({
  declarations: [
    ListadoComponent,
    HistorialVentaComponent,
    NuevaVentaComponent
  ],
  imports: [
    CommonModule,
    VentaRoutingModule
  ],
  providers: [TodoService], ******** Añadimos el Servicio.
})
export class VentaModule { }


----------------------- Para hacer peticiones Http --------------------------

------------------------------------------------------------------
1º Añadir el módulo de Angular que utilizaremos: HttpClientModule:

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent,
    CabeceraComponent,
    FormulariosComponent,
    Formularios2Component,
    TodosComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    ReactiveFormsModule,
    HttpClientModule  ************** Añadir este módulo para hacer peticiones Http
  ],
  providers: [TodoService],
  bootstrap: [AppComponent]
})
export class AppModule { }
 

------------------------------------------------------------------
2º Inyectar en el constructor del Servicio una instancia
del módulo HttpClientModule que hemos añadido:

@Injectable({
  providedIn: 'root'
})
export class TodoService {

  constructor(private http: HttpClient) { }
}


------------------------------------------------------------------
3º Implementar la petición Http en el Servicio:

@Injectable({
  providedIn: 'root'
})
export class TodoService {

  constructor(private http: HttpClient) {
  }

  // Implementamos la llamada Http:
  getTodos() {
      return this.http.get('https://jsonplaceholder.typicode.com/todos');
  }

}


------------------------------------------------------------------
4º Añadir en el template header.component.html un nuevo acceso:

<button [routerLink]="['/todos']" routerLinkActive="seccionActiva">Todos</button>


------------------------------------------------------------------
5º Añadir en el: app-routing.module.ts la nueva ruta:

import { TodosComponent } from './todos/todos.component';

const routes: Routes = [
	{ path: '', redirectTo: 'formularios', pathMatch: 'full'  },
	{ path: 'formularios', component: FormulariosComponent    },
	{ path: 'formularios2', component: Formularios2Component  },
	{ path: 'todos', component: TodosComponent  } ********************** Nueva ruta
];


------------------------------------------------------------------
6º Ahora tendremos que hacer uso del Servicio
dentro de nuestro nuevo componente: TodosComponent

export class TodosComponent implements OnInit {

  constructor(private todoService: TodoService) {}

  ngOnInit(): void {
    this.todoService.getTodos().subscribe(res => {
      console.log(res);
    }
  }



Todo el módulo que añadimos Http devuelve un Observable de un Objeto:

(method) TodoService.getTodos(): Observable<Object>
"@return — An Observable of the response body as a JavaScript object."

Un Observable es parecido a un flujo de datos que nos devolverá
una respuesta de manera Asíncrona
La respuesta llegará en un tiempo indeterminado, es una respuesta a futuro.

Lo que tengo que hacer para obtener esa respuesta a futuro
es suscribirme al evento que cuanto tenga la respuesta 
me va a devolver esa respuesta.

Dentro del subscribe, tendremos un Callback con lo que tenemos
que hacer con la respuesta, siendo 'res' la respuesta.

this.todoService.getTodos().subscribe(res => {
	console.log(res);
}

Ahora lo ejecutamos y en la consola del navegador
podemos visualizar el resultado de los valores obtenidos:

Array(200)
[0 … 99]
0: {userId: 1, id: 1, title: 'delectus aut autem', completed: false}
1: {userId: 1, id: 2, title: 'quis ut nam facilis et officia qui', completed: false}
2: {userId: 1, id: 3, title: 'fugiat veniam minus', completed: false}
...................................


Para poder ver el resultado en pantalla, sin explicar nada más
harímos los siguientes cambios:


En la clase del componente añadimos:
src > app > todos > todos.component.ts

export class TodosComponent implements OnInit {

  todos: any[] = []; // ************ Añadimos un array vacío para contener
						************ nuestros resultados.

  constructor(private todoService: TodoService) {}

	ngOnInit(): void {
		this.todoService.getTodos().subscribe((res: any) => {
			console.log(res);
			this.todos = res;
			console.log(this.todos);
		}
	}


En el template del componente añadimos:
src > app > todos > todos.component.html

<ul>
	<li *ngFor="let todo of todos"> {{todo.title}} </li>
</ul>


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-08-Forms-Clase-03-HTTP-Petición GET con params

Veremos como pasarle query params en la llamada al servicio, por ejemplo:

GET 	/comments?postId=1

https://jsonplaceholder.typicode.com/comments?postId=1


1º Reaprovechamos el Servicio anterior para el ejemplo e
implementamos la llamada Http y pasamos una parámetro a la ruta
------------------------------------------------------------------

@Injectable({
  providedIn: 'root'
})
export class TodoService {

  constructor(private http: HttpClient) {
  }

  // Implementamos la llamada Http y pasamos una parámetro a la ruta****************
  getComents(postId: number) {
      return this.http.get(`https://jsonplaceholder.typicode.com/comments?postId=${postId}`);
  }

}


2º Implementamos la llamada al método del Servicio
y pintamos el resultado en la consola
------------------------------------------------------------------

export class TodosComponent implements OnInit {
	constructor(private todoService: TodoService) {}
	ngOnInit(): void {
		this.todoService.getComents(1).subscribe((res: any) => {
			console.log('Comentarios...:'+res);
		});
	}
}


3º Implementamos la llamada al método del Servicio
utilizando otra sintaxis que nos permita enviar muchos parámetros de una forma agrupada.
------------------------------------------------------------------

  // Implementamos la llamada Http y pasamos los parámetros que necesitemos
  getComents2(postId: number) {
	const params = {
		postId: postId,
		param1: value1,
		param2: value2,
		... ... ... ... ... ... 
	}
    return this.http.get(`https://jsonplaceholder.typicode.com/comments`, {params});
  }

Invocamos al nuevo método desde la clase del componente que utiliza el servicio
y pintamos los resultados en la consola:

    this.todoService.getComents2(1).subscribe((res) => {
		console.log('Comentarios2...:', res);
    });


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-08-Forms-Clase-04-HTTP-Petición POST,PUT,DELETE

Ejemplo de petición POST:

POST 	/posts

En las peticiones Post se requiere un parámetro 'body'
(An argument for 'body' was not provided.)
como en nuestra función de llamada de ejemplo no vamos a utilizar
el parámetro 'body' le pasamos un null como parámetro 

  getPosts() {
    return this.http.post('https://jsonplaceholder.typicode.com/posts', null);
  }

Invocamos al nuevo método desde la clase del componente que utiliza el servicio
y pintamos los resultados en la consola:

    this.todoService.getPosts().subscribe((res) => {
			console.log('Posts...:', res);
    });


Para probar los métodos PUT, PATCH, DELETE
simplemente cambiamos el nombre del método en la llamada, algo así:
------------------------------------------------------------------

PUT 	/posts/1 ...: return this.http.put(`https://jsonplaceholder.typicode.com/posts/1`);

PATCH 	/posts/1 ...: return this.http.patch(`https://jsonplaceholder.typicode.com/posts/1`);

DELETE 	/posts/1 ...: return this.http.delete(`https://jsonplaceholder.typicode.com/posts/1`);


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-08-Forms-Clase-05-HTTP-Interceptores

Nos brinda la posibilidad de interceptar todas las peticiones que salgan de nuestro
frontent para ejecutar la lógica que necesitemos.

(1) Crearemos un nuevo Servicio en la carpeta services:

$ ng g s services/interceptor
CREATE src/app/services/interceptor.service.spec.ts (382 bytes)
CREATE src/app/services/interceptor.service.ts (140 bytes)

Nos crea el servicio:

import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class InterceptorService {

  constructor() { }
}

-----------------------------------------------------------------
(2) Añadimos la implementación 'implements HttpInterceptor'
y nos solicita implementar el método: 'intercept':

+ El parámetro: 'req' se corresponde con la petición
que hacemos y que es interceptada
por ejemplo: https://jsonplaceholder.typicode.com/comments?postId=1

+ El parámetro: 'next'
se refiere a la acción que se realizará acontinuación de la intercepción


import { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class InterceptorService implements HttpInterceptor {

  constructor() { }
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    throw new Error('Method not implemented.');
  }

}


-----------------------------------------------------------------
(2) Implementamos el método: 'intercept'

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log('Interceptado!');
	return next.handle(req);
  }


-----------------------------------------------------------------
(3) Comentamos en secciones anteriores que los Servicios que tenían
la anotación @Injectable con la propiedad: providedIn: 'root'
no era necesario definirla en el módulo.

@Injectable({
  providedIn: 'root'
})
export class InterceptorService implements HttpInterceptor {


Esto era correcto porque el Servicio se iba a utilizar desde
los componentes como:

constructor(private todoService: TodoService) {}

En este caso, el interceptor no va a ser utilizado
desde ningún componente sino que será utilizado desde el módulo
así que tenemos que definirlo:

  providers: [
	TodoService,
	{ provide: HTTP_INTERCEPTORS, useClass: InterceptorService, multi:true },
  ],

Ahora en la consola veremos una traza por cada una de las llamadas
que lanzábamos desde nuestro componente:

Por ejemplo, para la llamada:

    this.todoService.getTodos().subscribe((res: any) => {
			console.log(res);
			this.todos = res;
			console.log(this.todos);
    });

Se muestra:

	Interceptado!
	
-----------------------------------------------------------------
(4) Vamos a implementar nuevo código para nuestro interceptor
y añadiremos una nueva cabecera a la petición interceptada:

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    console.log('Interceptado!');
	const newReq = req.clone({
		setHeaders: {
			Authorizacion: 'FakeAuth'
		}
	})
	return next.handle(newReq);
  }

Ahora desde las herramientas del Chrome veremos desde la pestaña: 'Network'
en las cabeceras de la petición (Headers)
que se añadió a las cabeceras de la petición (Request Headers)
la cabecera que añadimos:

authorizacion: 'FakeAuth'


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-09-RxJS-Clase-01-Introducción a RxJS

RxJS es una librería de JavaScript que es utilizada por Angular.
Permite comunicar información entre distintos lugares con Observers y Subjects.
Es el pilar de la Reactividad.

Para la explicación, tomamos como ejemplo una cuenta de Twitter
donde una cuenta se corresponde con el Subject
y los Observers son los usuarios suscritos al Subject
y que serán notificados cuando el Subject transmita una comunicación.

En RxJS existe el concepto de Operadores (Operators)

Podemos representar también a los Observables como una manguera
que es el medio por el que va a pasar la información

Y los Operadores (Operators) transforman la salida de la información.


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-09-RxJS-Clase-02-RxJS-Casos prácticos


Recuperamos nuestro servicio desde el que hacíamos un llamada
al método getTodos()

export class TodoService {
  constructor(private http: HttpClient) {
  }
  getTodos() {
      return this.http.get('https://jsonplaceholder.typicode.com/todos');
  }


que devolvía un Observable de tipo Object:

(method) TodoService.getTodos(): Observable<Object>

Por lo que esto ya sería un Observable:

return this.http.get('https://jsonplaceholder.typicode.com/todos');

Y getTodos() devuelve un Observable.


Y desde el Componente nos suscribimos a la información que este canal vaya a emitir
y le mandamos una función de lo que vamos a hacer cuando obtengamos esa información.

  this.todoService.getTodos().subscribe((res: any) => {
		console.log(res);
		this.todos = res;
		console.log(this.todos);
  });


(1) Vamos a crear nuestro propio Observable en el Servicio:

Creamos el Subject, el canal de información:

import { Subject } form 'rxjs';

export class TodoService {

// Canal de información:
postSource = new Subject();

Y ahora creamos un Observable,
por convención los Observables terminan con $:

// Observable, que consumiremos desde los Componentes:
posts$ = this.postSource.asObservable();


(2) En la clase del componente, implementamos un método
para hacer uso del Subject:

src > app > todos > todos.component.ts

*El 'next('Información!')' se corresponde con abrir el grifo de la manguera
y enviamos nueva información con una cadena de texto 'Información!'
actualizando la salida de agua de nuestra manguera

updatePost(){
	this.todoService.postSource.next('Información!');
}


(3) Para llamar al método de la clase 'updatePost()' 
añadimos en el template del Componente un botón:

<button (click)="updatePost()">Actualizar posts</button>


Si ahora actualizamos el proyecto y hacemos clic en el botón
estamos emitiendo la información nueva
pero no hay nadie suscrito que pueda recibir esa información
y que se pueda mostrar en la consola.

Vamos a crear una suscripción desde el mismo componente así:

ngOnInit(): void {

 this.todoService.posts$.subscribe((res) => {
	console.log('Nuevos datos: ', res);
 });
... ... ... ... ... ... ... ... 


Si ahora hacemos clic en el botón visualizamos por la consola
> Nuevos datos:  Información!


(4) Para continuar con el ejemplo creamos un nuevo componente

$ ng g c todos/todo
CREATE src/app/todos/todo/todo.component.html (19 bytes)
CREATE src/app/todos/todo/todo.component.spec.ts (585 bytes)
CREATE src/app/todos/todo/todo.component.ts (194 bytes)
CREATE src/app/todos/todo/todo.component.css (0 bytes)
UPDATE src/app/app.module.ts (1245 bytes)


(5) Inyectamos el Servicio en el Constructor del nuevo componente
y nos suscribimos desde nuestro nuevo componente
y quitamos la suscripción del componente anterior.


export class TodoComponent  implements OnInit {
	constructor(private todoService: TodoService) {}  
	ngOnInit(): void {
		this.todoService.posts$.subscribe((res) => {
			console.log('Nuevos datos: ', res);
		});
	}
}


(6) Añadimos nuestro nuevo componente al componente todos:

<p>todos works!</p>
<br/>
<button (click)="updatePost()">Actualizar posts</button>
<br/><br/>
<ul>
  <li *ngFor="let todo of todos">{{todo.title}}</li>
</ul>

<app-todo></app-todo> ********* Añadido!


Ahora cuando haga clic en el botón del Componente todos.componnent
se transmitirá la información al nuevo Componete todo.component
a pesar de que ambos componentes no están conectados.

Por lo tanto podemos utilizar un Subject para comunicar información
entre nuestros componentes que no necesitan estar ni tan siquiera
relacionados. Podemos comunicarlos a través de los Observables.


---------------------------------------------------------------------
También podemos dejar creados los dos Observables subscritos
en cada componente, de esta forma nos llegaría la transmisión
del Subject a ambos:

Observable componente "todos.component" datos1 :  Información!
Observable componente "todo.component"  datos2 :  Información!


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-09-RxJS-Clase-03-RxJS-Operadores

Los Operadores transforman la información que nos llegan a los Observables
Añadimos '.pipe()' después del Observable
y añadimos los operadores necesarios:

(1) Operador: map

export class TodoComponent  implements OnInit {
	constructor(private todoService: TodoService) {}  
	ngOnInit(): void {
		this.todoService.posts$.pipe( *********** Añadimos los operadores
			map( res => {
				console.log(res);
				return res; *********** Es obligatorio devoler algo si queremos
							*********** que continúe el flujo
			})
		)
		.subscribe((res) => {
			console.log('Nuevos datos: ', res);
		});
	}
}


(2) Podríamos cambiar la llamada por un array:

updatePost(){
	this.todoService.postSource.next([1,2,3,4,5]);
}

(3) Y también podríamos transformar la respuesta:

	this.todoService.posts$.pipe( *********** Añadimos los operadores
		map( res => {
			console.log(res);
			res = ['uno','dos','tres'];
			return res; 
		})

(4) Hacemos un ejemplo para filtrar el resultado

Definimos el Subject de un tipo específico: Array de numbers

postSource = new Subject<number[]>(); ****** Definimos de tipo number
posts$ = this.postSource.asObservable();


(5) Ahora res, es un Array de numbers y puedo hacer uso
de las funciones de los arrays como 'filter'
En la salida se mostrarán los números del array mayores de 3.

this.todoService.posts$.pipe( *********** Añadimos los operadores
	map( res: number[] => {   *********** res está definido como un Array de numbers
		console.log(res);
		return res.filter( num => num > 3); 
	})
)

Se muestra en la consola:
(2) [4, 5]


(6) Si queremos también podemos aplicar el pipe con el filtro
a la definición del Observable para que cuando me suscriba ya obtenga los datos filtrados.

posts$ = this.postSource.asObservable().pipe( *********** Añadimos los operadores
	map((res): number[] => {
		console.log(res);
		return res.filter( num => num > 3); 
	})
);


(7) Operador: tap

El Operador 'tap' es un operador especial que no interrumpe
ni afecta al flujo de los datos.
De hecho ni siquiera es necesario el return.

Este Operador nos será muy útil por ejemplo para depurar
o también mostrar por consola los resultados.

export class TodoComponent  implements OnInit {
	constructor(private todoService: TodoService) {}  
	ngOnInit(): void {
		this.todoService.posts$.pipe( *********** Añadimos los operadores
			map( res: number[] => {
				console.log(res);
				return res.filter( num => num > 3); 
			}),
			tap( (res) => {
				console.log('Desde el tap:' ,res);
			})	
		)
		.subscribe((res) => {
			console.log('Nuevos datos: ', res);
		});
	}
}


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-10-ProyectoFinal-Clase-01-Demostración del proyecto final
Módulo-10-ProyectoFinal-Clase-02-Estructura del proyecto
Módulo-10-ProyectoFinal-Clase-03-Wireframes del proyecto

Crearemos un nuevo proyecto de Angular como proyecto final del curso
y explotaremos un API REST de cartas:

Creamos el proyecto y creamos unas carpetas para la estructura:

$ ng new 0015-curso-profesional-angular-proyecto-final
$ cd 0015-curso-profesional-angular-proyecto-final

Creamos las carpetas:
$ mkdir src/app/components
$ mkdir src/app/interfaces
$ mkdir src/app/pages
$ mkdir src/app/services



-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-10-ProyectoFinal-Clase-04-Listado-Creando los componentes

(1) Creamos el componente Card para representar una carta:

$ ng g c components/card
CREATE src/app/components/card/card.component.html (19 bytes)
CREATE src/app/components/card/card.component.spec.ts (585 bytes)
CREATE src/app/components/card/card.component.ts (194 bytes)
CREATE src/app/components/card/card.component.css (0 bytes)
UPDATE src/app/app.module.ts (478 bytes)


(2) Creamos los componentes para las dos páginas de la aplicación

$ ng g c pages/list   (para el listado de cartas)
---------------------------------------------------------------------
CREATE src/app/pages/list/list.component.html (19 bytes)
CREATE src/app/pages/list/list.component.spec.ts (585 bytes)
CREATE src/app/pages/list/list.component.ts (194 bytes)
CREATE src/app/pages/list/list.component.css (0 bytes)
UPDATE src/app/app.module.ts (558 bytes)

$ ng g c pages/detail (para el detalle de la carta seleccionada)
---------------------------------------------------------------------
CREATE src/app/pages/detail/detail.component.html (21 bytes)
CREATE src/app/pages/detail/detail.component.spec.ts (599 bytes)
CREATE src/app/pages/detail/detail.component.ts (202 bytes)
CREATE src/app/pages/detail/detail.component.css (0 bytes)
UPDATE src/app/app.module.ts (646 bytes)


(3) En el módulo de rutas añadimos las rutas a las páginas:

src > app > app-routing.module.ts

const routes: Routes = [
	{ path: '', component: ListComponent },
	{ path: 'card/:id' , component: DetailComponent }
];


(4) Añadimos en el app.component.html
la etiqueta <router-outlet> para que se pinten las páginas:

<div class="content">
	<router-outlet></router-outlet>
</div>


(5) Creamos el repositorio: 0015-curso-profesional-angular-proyecto-final
en GitHub y subimos todos los cambios:

echo "# 0015-curso-profesional-angular-proyecto-final" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/RenegadeAsturias/0015-curso-profesional-angular-proyecto-final.git
git push -u origin main


(6) Probamos las rutas:

Con http://localhost:4200 visualizamos el listado

y con http://localhost:4200/card/123456 visualizamos la pantalla de detalle


(7) En el app.component.css añadimos unos estilos:


: host {
	display: flex;
	flex-direction: column;
	height: 100%;
}

.content {
	margin: 0;
	background-color: #1D90CE;
	flex: 1;
	position: relative;
}


(8) en el src > index.html añadimos:

<head>
	... ... ... ... ... ... ... 
	<link rel="icon" type="image/x-icon" href="favicon.ico">
	
	-- Para obtener los estilos de bootstrap:
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">
	
	-- Para obtener la fuente: Lato de google fonts
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
</head>



(9) Creamos un buscador en
scr > app > pages > list > list.component.html

<div class="list">
  <input type="text" class="form-control" placeholder="Buscar una carta"/>
</div>



(10) Y definimos unos estilos para dejarlo bonito en
scr > app > pages > list > list.component.css

.list {
  width: 80%;
  margin: auto;
  margin-top: 2em;
}


(11) Antes de abordar la llamada a la API para traer las cartas
vamos a maquetar una carta a fuego para ver como queda:

scr > app > components > card > card.component.html

<div class="ygo-card">
	<img src="https://images.ygoprodeck.com/images/cards/6983839.jpg" alt="">
</div>


(12) Definimos unos estilos para la clase del div de la carta: 'ygo-card' en:

scr > app > components > card > card.component.css

.ygo-card img {
		width: 100%;
		object-fit: cover;
		width: 200px;
}

(13) Mostramos la carta en:
scr > app > pages > list > list.component.html

<div class="list">
  <input type="text" class="form-control" placeholder="Buscar una carta"/>
  
  <app-card></app-card>
</div>


(14) Ahora modificamos el código para que en lugar de una sola carta
se pinte una lista de cartas repetidas utilizando una lista:

<div class="list">
	<input type="text" class="form-control" placeholder="Buscar una carta"/>
	<div class="cards">
		<app-card *ngFor="let card of [1,2,3,4,5,6,7,8,9]"></app-card>
	</div>
</div>


(15) definimos el estilo de la clase 'cards' para que se muestre en forma de tabla

scr > app > pages > list > list.component.css

.list {
  width: 80%;
  margin: auto;
  margin-top: 2em;
}

.cards {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(12em, 1fr));
	gap: 0.5em;
	margin-top: 2em;
}


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-10-ProyectoFinal-Clase-05-Listado-Funcionalidad del listado

(1) Desde la página : https://ygoprodeck.com/api-guide/
podemos ver cómo va ser la información de cada carta:

{
  "data": [
    {
      "id": 23771716,
      "name": "7 Colored Fish",
      "type": "Normal Monster",
      "frameType": "normal",
      "desc": "A rare rainbow fish that has never been caught by mortal man.",
      "atk": 1800,
      "def": 800,
      "level": 4,
      "race": "Fish",
      "attribute": "WATER",
      "card_sets": [
        {
          "set_name": "Gold Series",
          "set_code": "GLD1-EN001",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "0.74"
        },
        {
          "set_name": "Metal Raiders",
          "set_code": "MRD-098",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "1.06"
        },
        {
          "set_name": "Metal Raiders",
          "set_code": "MRD-E098",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "2.63"
        },
        {
          "set_name": "Metal Raiders",
          "set_code": "MRD-EN098",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "2.95"
        },
        {
          "set_name": "Starter Deck: Joey",
          "set_code": "SDJ-008",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "1.02"
        },
        {
          "set_name": "Structure Deck: Fury from the Deep",
          "set_code": "SD4-EN002",
          "set_rarity": "Common",
          "set_rarity_code": "(C)",
          "set_price": "1.12"
        }
      ],
      "card_images": [
        {
          "id": 23771716,
          "image_url": "https://images.ygoprodeck.com/images/cards/23771716.jpg",
          "image_url_small": "https://images.ygoprodeck.com/images/cards_small/23771716.jpg",
          "image_url_cropped": "https://images.ygoprodeck.com/images/cards_cropped/23771716.jpg"
        }
      ],
      "card_prices": [
        {
          "cardmarket_price": "0.07",
          "tcgplayer_price": "0.23",
          "ebay_price": "1.75",
          "amazon_price": "0.25",
          "coolstuffinc_price": "0.25"
        }
      ]
    }]
}

(2) La idea es maquetar esa información y para ello vamos a utilizar la siguiente herramienta:

https://quicktype.io/

Pegamos el código JSON obtenido de la API e indicamos que queremos la salida para Typescript
y obtenemos:

export interface CardResponse {
    data: Datum[];
}

export interface Datum {
    id:          number;
    name:        string;
    type:        string;
    frameType:   string;
    desc:        string;
    atk:         number;
    def:         number;
    level:       number;
    race:        string;
    attribute:   string;
    card_sets:   CardSet[];
    card_images: CardImage[];
    card_prices: CardPrice[];
}

export interface CardImage {
    id:                number;
    image_url:         string;
    image_url_small:   string;
    image_url_cropped: string;
}

export interface CardPrice {
    cardmarket_price:   string;
    tcgplayer_price:    string;
    ebay_price:         string;
    amazon_price:       string;
    coolstuffinc_price: string;
}

export interface CardSet {
    set_name:        string;
    set_code:        string;
    set_rarity:      string;
    set_rarity_code: string;
    set_price:       string;
}


(3) Modificamos un poco la salida:

(3.1) quitamos:

export interface CardResponse {
    data: Datum[];
}

(3.2) renombramos la segunda interface 'Datum' como:

export interface Card {
    id:          number;
	... ... ... ...


(4) En nuestra carpeta: src > app > interface
creamos un nuevo fichero para guardar las interfaces creadas:

src > app > interface > card.interfaces.ts


(5) Creamos un nuevo servicio para consumir los datos de la API:

ng g s services/card
CREATE src/app/services/card.service.spec.ts (347 bytes)
CREATE src/app/services/card.service.ts (133 bytes)


(6) Desde el servicio utilizaremos HttpClientModule


(6.1) Para hacer peticiones Http --------------------------

Añadir al módulo de Angular que utilizaremos: HttpClientModule así:

import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [
    AppComponent, CardComponent, ListComponent, DetailComponent
  ],
  imports: [
    BrowserModule, AppRoutingModule, HttpClientModule ************** Añadir este módulo para hacer peticiones Http
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }


(6.2) En el servicio inyectamos HttpClient para hacer uso de HttpClientModule
también añadimos una variable para guardar la ruta fija de la llamada
y una función para obtener el listado de cartas:

constructor(private http: HttpClient) { }

Tendríamos:

import { HttpClient } from '@angular/common/http';
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class CardService {
    API_URL ='https://db.ygoprodeck.com/api/v7/cardinfo.php';
    constructor(private http: HttpClient) { }
	
	getCards() {
		return this.http.get<Card[]>(this.API_URL);
	}	
}




