
Apuntes-Angular. Curso Angular Avanzado (LinkedIn Learning) (2023)

0.Introducción
1.Presentación

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Preparación de las bases del proyecto
-------------------------------------------------------------

$ ng new componentesAvanzados

#Como preparación del proyecto nos propone:

#1 Incluir un framework de trabajo para css
<link rel="stylesheet" 
href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.css"/>

#2 Añadimos unas imágenes en la carpeta assets del proyecto:
src > app > products > mineralwater-orange.jpg
src > app > products > mineralwater-strawberry.jpg
src > app > products > proteinbar-chocolate.jpg

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Instalar modelos, interfaces y componentes base
-------------------------------------------------------------

#1 Definimos una clase (modelo)
$ ng generate class models/tienda.model
$ CREATE src/app/models/tienda.model.spec.ts
$ CREATE src/app/models/tienda.model.ts

#Entramos en la clase y le cambiamos el nombre (le quitamos el models)
#y se queda:
export class Tienda { }

#Ahora definimos el modelo:
export class Tienda { 

	// Definimos un array para guardar los Items de mi tienda
	tiendaItems:Array<Object>
	
	constructor(){
		// Cargamos el array con los Items de mi tienda
		this.tiendaItems = [
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "mineralwater-orange.jpg",
			precio: 20
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Strawberry Mineral Water ",
			imagen: "mineralwater-strawberry.jpg",
			precio: 33
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "proteinbar-chocolate.jpg",
			precio: 120
			}
		];
	}

}

#Ahora creamos un interface que defina la estructura del modelo

$ ng generate interface interfaces/Producto
CREATE src/app/interfaces/producto.ts

#Entramos en el interface y lo definimos:

export interface Producto {
	precio?: number;
	titulo?: string;
	imagen?: string;
	texto?:  string;
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Qué son los componentes statefull y staleless
-------------------------------------------------------------

#Los componentes statefull
son los componentes que contienen información, operaciones
y posíblemente otros componentes staleless


#Los componentes staleless
son componentes que no contienen un estado
en general son componentes simples
que lo que hacen es desplegar información

#1 Vamos a crear un componente statefull
$ ng generate component con-estado

#2 Vamos la plantilla de componente principal
src > app > app.component.html

#3 Incluimos dentro el componente que hemos creado
<app-con-estado></app-con-estado>

#4 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts

#Importamos el interface y el modelo
import { Producto } from "../interfaces/producto";
import { Tienda } from "../models/tienda.model";

#Creamos dos variables en la clase
export class ConEstadoComponent implements OnInit {
	modeloTienda:Tienda = new Tienda();
	itemsComprados:Array<Producto>;

#5 Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		{{item.titulo}}
		<!----------- --------------->
	</div>
</div>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes statefull
-------------------------------------------------------------

#Un componente statefull tiene la capacidad de almacenar información
y en algunos casos incluso de procesarla.

#1 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Estoy mostrando un listado de productos y aparece un botón de comprar el producto en su ficha.
#Al hacer clic capturamos el item mostrasdo en cada caso.
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#2 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts
#Implementamos el método que se invoca en el evento clic: seleccionarItem(item)

export class ConEstadoComponent implements OnInit {

modeloTienda:Tienda = new Tienda();
itemsComprados:Array<Producto>;

constructor() {
	this.itemsComprados=[]; // Inicializamos el Array
}

seleccionarItem(item) {
	this.itemsComprados.push(item);
}

#3 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Vamos a mostrar también el array con la lista de items comprados
#Así desplegamos un componente de tipo statefull
<section>
	<li *ngFor="let itemComprado of itemsComprados">{{itemComprado.titulo}}
</section>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes stateless
-------------------------------------------------------------

#Un es un componente que solo despliega datos
#Y si realiza algún proceso será un proceso interno que no variables
#a afectar a esos datos.

#1 Creamos un componente sin estado
$ ng generate component sin-estado

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Vamos a copiar el código HTML que mostraba la información
#de cada uno de los items que estábamos mostrando antes
#en la plantilla del componente con estado:

<!----------- --------------->
{{item.titulo}}
<!----------- --------------->

<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#3 Vamos de nuevo al componente principal donde ahora
#vamos a tener una relación padre-hijo
#incluyendo en él el componente sin-estado

#Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		<app-sin-estado></app-sin-estado> .......Incluimos el componente hijo
		<!----------- --------------->
	</div>
</div>

#Ojo! Que se muestra la plantilla pero no se visualiza la información
#ésto lo solucionaremos en la próxima sección

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Captura de datos con @Input
-------------------------------------------------------------

#La relación que se establece entre un componente con estado (statefull)
#y un componente sin estado (stateless)
#es prácticamente indispensable que el componente staleless reciba información
#del componente statefull

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir

import { Producto } from "../../interfaces/producto";

#La nomenglatura: @Input() permite exponer o inyectar información
#en este ejemplo vamos a recibir un objeto de tipo Producto

export class SinEstadoComponent implements OnInit {

	@Input() producto: Producto;


#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Cambiamos todas las notaciones de referencia al objeto
#que teníamos cuando estaba acoplada al componente statefull
#ahora nuestro objeto es: producto

{{item.precio}} -----> {{producto.precio}}
{{item.titulo}} -----> {{producto.titulo}}
{{item.imagen}} -----> {{producto.imagen}}
{{item.texto}} ------> {{producto.texto}}

#3 Ahora nos queda decirle a nuestro componente padre (statefull)
#que puede enviarnos información sobre el item sobre el que estamos trabajando
#Modificamos en la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		
		#Añadimos [producto]="item"
		#esto inyecta en nuestro componente hijo sin estado (staleless)
		#en nuestro @Input() producto el item en curso
		
		<app-sin-estado [producto]="item"></app-sin-estado>
		<!----------- --------------->
	</div>
</div>

#En resumen el componente padre (statefull) que tiene toda la información
#inyecta y pasa inforación a su componente hijo (staleless) 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Lógica interna de un componente staleless
-------------------------------------------------------------

#El objetivo principal de utilizar componentes stateless
#es mantener nuestra lógica distribuída y funcional.
#Podemos utilizar procedimientos internos siempre y cuando permanezcan encapsulados.

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir dos propiedades

export class SinEstadoComponent implements OnInit {
@Input() producto: Producto;

private disabled:boolean;
public accionCompra:string;

#Incializamos el valor de una de las variables

#Ojo!!! queremos inicialiar la variable con la siguiente sintaxis:
this.accionCompra = `BUY FOR € ${this.producto.precio}´};

#Quizás podríamos pensar en colocarlo en el constructor
constructor() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#O quizás podríamos pensar en colocarlo en el ngOnInit() 
ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#Explicación de dónde debería ir y por qué:

#Si lo ponemos en el constructor vamos a tener un problema
#El constructor va a estar definido en el momento en el que se crea nuestra aplicación
#pero no en el momento en que invocamos nuestro componente.

#El código debería incluirse en el ngOnInit para que funcione correctamente
#El ngOnInit nos va desplegar los datos en el momento en que este componente está disponible.
#cuando ya tenemos acceso a los valores de Producto o Precio.

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
... ... ... ... ...
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#Reemplazamos el código que teníamos anteriormente:
BUY FOR € ${this.producto.precio}

#Por la nueva variable que ahora tiene el mismo valor
<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>


#3 Nos damos cuenta también que cuando movimos el código
#del componente padre con-estado (statefull) con todos los datos
#al componente hijo sin-estado (staleless)
#El siguiente código que manejaba el evento click perdió su funcionalidad:

<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>

#Cambiamos en la plantilla el código anterior por:
<button class="button" (click)="seleccionarItem()" >
	{{accionCompra}} 
</button>

#4 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar de nuevo el método:

export class SinEstadoComponent implements OnInit {

private disabled:boolean;
public accionCompra:string;

ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

seleccionarItem() {
	this.disabled = true; // Por defecto en su definición es false
	this.accionCompra = "AÑADIDO AL CARRITO!";
}

#5 Vamos a cambiar un poco más el componente y vamos a aprovechar la variable disabled
#En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
#Utilizamos la sintaxis [<propiedad_de_HTML>] para definir su valor
#Por ejemplo:

#La propiedad HTML disabled del botón tomará su valor del método
<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()" 
>
	{{accionCompra}} 
</button>

#6 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar el nuevo método

isItemDisabled() {
	return !this.disabled;
}

#7 Un último cambio, vamos a añadir una clase css al botón
#utlizando la siguiente sintaxis:

#La propiedad HTML disabled del botón tomará su valor del método
#Si el producto no ha sido comprado y por tanto el botón no está disabled
#se le añadirá una clases que haga más llamativo el botón de comprar
#y se traduciría por algo así: <button class"button is-danger"...

<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()"
	[ngClass]="{'is-danger':!isItemDisabled()}"
>
	{{accionCompra}} 
</button>

#Estamos realizando cálculos, realizando procesos dentro de nuestro componente
#pero en ningún caso afectan a los valores... no estamos cambiando los precios,
#no estamos cambiando ningún estado...
#Cada uno de los componentes stalelessse mantiene completamente encapsulado 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Envío de enventos con @Output
-------------------------------------------------------------




