
Apuntes-Angular. Curso Angular Avanzado (LinkedIn Learning) (2023)

0.Introducción
1.Presentación

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Preparación de las bases del proyecto
-------------------------------------------------------------

$ ng new componentesAvanzados

#Como preparación del proyecto nos propone:

#1 Incluir un framework de trabajo para css
<link rel="stylesheet" 
href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.css"/>

#2 Añadimos unas imágenes en la carpeta assets del proyecto:
src > app > products > mineralwater-orange.jpg
src > app > products > mineralwater-strawberry.jpg
src > app > products > proteinbar-chocolate.jpg

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Instalar modelos, interfaces y componentes base
-------------------------------------------------------------

#1 Definimos una clase (modelo)
$ ng generate class models/tienda.model
$ CREATE src/app/models/tienda.model.spec.ts
$ CREATE src/app/models/tienda.model.ts

#Entramos en la clase y le cambiamos el nombre (le quitamos el models)
#y se queda:
export class Tienda { }

#Ahora definimos el modelo:
export class Tienda { 

	// Definimos un array para guardar los Items de mi tienda
	tiendaItems:Array<Object>
	
	constructor(){
		// Cargamos el array con los Items de mi tienda
		this.tiendaItems = [
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "mineralwater-orange.jpg",
			precio: 20
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Strawberry Mineral Water ",
			imagen: "mineralwater-strawberry.jpg",
			precio: 33
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "proteinbar-chocolate.jpg",
			precio: 120
			}
		];
	}

}

#Ahora creamos un interface que defina la estructura del modelo

$ ng generate interface interfaces/Producto
CREATE src/app/interfaces/producto.ts

#Entramos en el interface y lo definimos:

export interface Producto {
	precio?: number;
	titulo?: string;
	imagen?: string;
	texto?:  string;
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Qué son los componentes statefull y staleless
-------------------------------------------------------------

#Los componentes statefull
son los componentes que contienen información, operaciones
y posíblemente otros componentes staleless


#Los componentes staleless
son componentes que no contienen un estado
en general son componentes simples
que lo que hacen es desplegar información

#1 Vamos a crear un componente statefull
$ ng generate component con-estado

#2 Vamos la plantilla de componente principal
src > app > app.component.html

#3 Incluimos dentro el componente que hemos creado
<app-con-estado></app-con-estado>

#4 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts

#Importamos el interface y el modelo
import { Producto } from "../interfaces/producto";
import { Tienda } from "../models/tienda.model";

#Creamos dos variables en la clase
export class ConEstadoComponent implements OnInit {
	modeloTienda:Tienda = new Tienda();
	itemsComprados:Array<Producto>;

#5 Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		{{item.titulo}}
		<!----------- --------------->
	</div>
</div>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes statefull
-------------------------------------------------------------

#Un componente statefull tiene la capacidad de almacenar información
y en algunos casos incluso de procesarla.

#1 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Estoy mostrando un listado de productos y aparece un botón de comprar el producto en su ficha.
#Al hacer clic capturamos el item mostrasdo en cada caso.
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#2 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts
#Implementamos el método que se invoca en el evento clic: seleccionarItem(item)

export class ConEstadoComponent implements OnInit {

modeloTienda:Tienda = new Tienda();
itemsComprados:Array<Producto>;

constructor() {
	this.itemsComprados=[]; // Inicializamos el Array
}

seleccionarItem(item) {
	this.itemsComprados.push(item);
}

#3 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Vamos a mostrar también el array con la lista de items comprados
#Así desplegamos un componente de tipo statefull
<section>
	<li *ngFor="let itemComprado of itemsComprados">{{itemComprado.titulo}}
</section>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes stateless
-------------------------------------------------------------

#Un es un componente que solo despliega datos
#Y si realiza algún proceso será un proceso interno que no variables
#a afectar a esos datos.

#1 Creamos un componente sin estado
$ ng generate component sin-estado

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Vamos a copiar el código HTML que mostraba la información
#de cada uno de los items que estábamos mostrando antes
#en la plantilla del componente con estado:

<!----------- --------------->
{{item.titulo}}
<!----------- --------------->

<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#3 Vamos de nuevo al componente principal donde ahora
#vamos a tener una relación padre-hijo
#incluyendo en él el componente sin-estado

#Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		<app-sin-estado></app-sin-estado> .......Incluimos el componente hijo
		<!----------- --------------->
	</div>
</div>

#Ojo! Que se muestra la plantilla pero no se visualiza la información
#ésto lo solucionaremos en la próxima sección

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Captura de datos con @Input
-------------------------------------------------------------

#La relación que se establece entre un componente con estado (statefull)
#y un componente sin estado (stateless)
#es prácticamente indispensable que el componente staleless reciba información
#del componente statefull

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir

import { Producto } from "../../interfaces/producto";

#La nomenglatura: @Input() permite exponer o inyectar información
#en este ejemplo vamos a recibir un objeto de tipo Producto

export class SinEstadoComponent implements OnInit {

	@Input() producto: Producto;


#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Cambiamos todas las notaciones de referencia al objeto
#que teníamos cuando estaba acoplada al componente statefull
#ahora nuestro objeto es: producto

{{item.precio}} -----> {{producto.precio}}
{{item.titulo}} -----> {{producto.titulo}}
{{item.imagen}} -----> {{producto.imagen}}
{{item.texto}} ------> {{producto.texto}}

#3 Ahora nos queda decirle a nuestro componente padre (statefull)
#que puede enviarnos información sobre el item sobre el que estamos trabajando
#Modificamos en la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		
		#Añadimos [producto]="item"
		#esto inyecta en nuestro componente hijo sin estado (staleless)
		#en nuestro @Input() producto el item en curso
		
		<app-sin-estado [producto]="item"></app-sin-estado>
		<!----------- --------------->
	</div>
</div>

#En resumen el componente padre (statefull) que tiene toda la información
#inyecta y pasa inforación a su componente hijo (staleless) 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Lógica interna de un componente staleless
-------------------------------------------------------------

#El objetivo principal de utilizar componentes stateless
#es mantener nuestra lógica distribuída y funcional.
#Podemos utilizar procedimientos internos siempre y cuando permanezcan encapsulados.

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir dos propiedades

export class SinEstadoComponent implements OnInit {
@Input() producto: Producto;

private disabled:boolean;
public accionCompra:string;

#Incializamos el valor de una de las variables

#Ojo!!! queremos inicialiar la variable con la siguiente sintaxis:
this.accionCompra = `BUY FOR € ${this.producto.precio}´};

#Quizás podríamos pensar en colocarlo en el constructor
constructor() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#O quizás podríamos pensar en colocarlo en el ngOnInit() 
ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#Explicación de dónde debería ir y por qué:

#Si lo ponemos en el constructor vamos a tener un problema
#El constructor va a estar definido en el momento en el que se crea nuestra aplicación
#pero no en el momento en que invocamos nuestro componente.

#El código debería incluirse en el ngOnInit para que funcione correctamente
#El ngOnInit nos va desplegar los datos en el momento en que este componente está disponible.
#cuando ya tenemos acceso a los valores de Producto o Precio.

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
... ... ... ... ...
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#Reemplazamos el código que teníamos anteriormente:
BUY FOR € ${this.producto.precio}

#Por la nueva variable que ahora tiene el mismo valor
<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>


#3 Nos damos cuenta también que cuando movimos el código
#del componente padre con-estado (statefull) con todos los datos
#al componente hijo sin-estado (staleless)
#El siguiente código que manejaba el evento click perdió su funcionalidad:

<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>

#Cambiamos en la plantilla el código anterior por:
<button class="button" (click)="seleccionarItem()" >
	{{accionCompra}} 
</button>

#4 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar de nuevo el método:

export class SinEstadoComponent implements OnInit {

private disabled:boolean;
public accionCompra:string;

ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

seleccionarItem() {
	this.disabled = true; // Por defecto en su definición es false
	this.accionCompra = "AÑADIDO AL CARRITO!";
}

#5 Vamos a cambiar un poco más el componente y vamos a aprovechar la variable disabled
#En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
#Utilizamos la sintaxis [<propiedad_de_HTML>] para definir su valor
#Por ejemplo:

#La propiedad HTML disabled del botón tomará su valor del método
<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()" 
>
	{{accionCompra}} 
</button>

#6 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar el nuevo método

isItemDisabled() {
	return !this.disabled;
}

#7 Un último cambio, vamos a añadir una clase css al botón
#utlizando la siguiente sintaxis:

#La propiedad HTML disabled del botón tomará su valor del método
#Si el producto no ha sido comprado y por tanto el botón no está disabled
#se le añadirá una clases que haga más llamativo el botón de comprar
#y se traduciría por algo así: <button class"button is-danger"...

<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()"
	[ngClass]="{'is-danger':!isItemDisabled()}"
>
	{{accionCompra}} 
</button>

#Estamos realizando cálculos, realizando procesos dentro de nuestro componente
#pero en ningún caso afectan a los valores... no estamos cambiando los precios,
#no estamos cambiando ningún estado...
#Cada uno de los componentes stalelessse mantiene completamente encapsulado 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Envío de enventos con @Output
-------------------------------------------------------------

#Estamos trabajando con un componente padre statefull
#y tres componentes hijos staleless

#Desde el componente padre statefull estamos inyectando información
#a los componentes hijos staleless

#Para hacer esto hemos declarado en el clase del componente hijo
#la siguiente declaración: @Input() producto: Producto;

#Tendríamos:
export class SinEstadoComponent implements OnInit {
	@Input() producto: Producto;

#Y ahora el componente padre inyecta información
#a través de ese objeto, en la llamada al componente hijo
#Añadimos [producto]="item"
#esto inyecta en nuestro componente hijo sin estado (staleless)
#en nuestro @Input() producto el item en curso

<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
<!----------- --------------->
	<app-sin-estado [producto]="item"></app-sin-estado>


#Ahora vamos enviarle información desde los componentes hijos statefull
#al componente padre staleless para que modifique los datos

#La forma en que vamos a interactuar entre estos dos elementos
#es a partir de los eventos.
#Entonces, el componente hijo, cuando reciba algún tipo de cambio relevante
#en este caso, cuando se le hace clic a un botón
#va a avisar al padre que hubo una interacción del usuario
#y que es posible que necesitemos modificar los datos
#pero nunca el componente sin-estado stateless tiene que realizar esos cambios
#y todo lo que ocurra dentro del componente con estado debe estar encapsulado.

#1 En la clase del componente sin-estado
Añadir al import: EvenEmitter y asegurarse que apunta al '@angular/core'

import { Component, OnInit, Input, Output, EvenEmitter } from "@angular/core";

@Input producto: Producto;

#Esto es un emisor de eventos que nos permite enviar información al padre
@Output productoSeleccionado: EventEmitter<Producto> = new EvenEmitter()

#2 Vamos a reutilizar el evento que tenemos definido en los componentes stateless

<button class="button" (click)="seleccionarItem()" -->Definido en el clic del botón

#En la implementación del método añadimos lo siguiente para despachar el evento
#emitiremos un evento de tipo producto
seleccionarItem() {
	this.disabled = true; // Por defecto en su definición es false
	this.accionCompra = "AÑADIDO AL CARRITO!";
	#Para el evento:________________________________
	this.productoSeleccionado.emit(this.producto)
}

#3 Ahora implementamos la captura del evento
#para capturarlo cada vez que se despache cuando ocurra el evento.
#En Angular siempre capturamos los eventos a partir de los paréntesis.
#En la plantilla del componente padre statefull añadimos:

<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
<!----------- --------------->
	<app-sin-estado 
		[producto]="item"
		# Para el evento:________________________________
		(productoSeleccionado)="onProductoSeleccionado($event)"
	>
	</app-sin-estado>
	
#4 Ahora en la clase del componente padre statefull implementamos el método:
onProductoSeleccionado(_event: Producto){
	console.log(_event);
}

#5 Ahora hacemos clic sobre uno de los botones de un componente disparando el evento.
#Ahora podemos ver en la consola del navegador cómo se ha despachado un evento producto
#y lo hemos capturado correctamente.
#Se imprime en la consola la información del producto sobre el que hicimos clic.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Integración de componentes statefull con componentes staleless
-------------------------------------------------------------

#1 Retomamos el ejemplo anterior y cambiamos el console.log
#por una llamada a un método que ya teníamos implementado:

seleccionarItem(item) {
	this.itemsComprados.push(item);
}

onProductoSeleccionado(_event: Producto){
	seleccionarItem(_event);
}

#2 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Mostrábamos también el array con la lista de items comprados
<section>
	<li *ngFor="let itemComprado of itemsComprados">{{itemComprado.titulo}}</li>
</section>

#3 Retocamos la plantilla de nuestro componente con-estado
en el apartado anterior para mostrar mejor la información
Mostramos el título y a su derecha el precio del producto
<section>
	<li *ngFor="let itemComprado of itemsComprados">
		Título:{{itemComprado.titulo}}<br/>
		Precio:{{itemComprado.precio | currency}}
	</li>
</section>

#4 Añadimos también un campo con el total de todos los productos comprados
<br>Total comprados: {{getPrecioTotal() | currency }}

#5 Implementamos en la clase del componente padre statefull
#el método para sumar los productos comprados

getPrecioTotal(){
	if(this.itemsComprados){
		return this.itemsComprados.reduce(
			(prev:number,item:Producto) => prev + item.precio, 0);
		);
	}
}

#6 Un cambio más. Para que no se vea el contenido de la sección vacía
#si aún no hemos comprado compoenentes hacemos la siguiente modificación

<section>
	<div *ngIf="itemsComprados.length > 0">
		<p>Listado de elementos comprados</p>
		<li *ngFor="let itemComprado of itemsComprados">
			Título:{{itemComprado.titulo}}<br/>
			Precio:{{itemComprado.precio | currency}}
		</li>
	</div>
</section>


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Interacción entre componentes
+Control de componentes anidados con @viewChild
-------------------------------------------------------------






