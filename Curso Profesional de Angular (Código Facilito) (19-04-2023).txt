
Curso Profesional de Angular (Código Facilito) (19/04/2023)

Temario:

Módulo-01-Introducción-Clase-01-Presentación del curso
Módulo-01-Introducción-Clase-02-Qué aprenderás y requisitos previos
Módulo-01-Introducción-Clase-03-Qué es y qué podemos hacer con Angular

Módulo-02-EntornoTrabajo-Clase-01-Instalando Angular
Módulo-02-EntornoTrabajo-Clase-02-Instalando VSCode y Extensiones
Módulo-02-EntornoTrabajo-Clase-03-Explorando el Angular CLI
Módulo-02-EntornoTrabajo-Clase-04-Estructura proyecto Angular

Módulo-03-Componentes-Clase-01-Qué es un componente
Módulo-03-Componentes-Clase-02-Creando un componente

Módulo-04-Directivas-Clase-01-Qué son las directivas
Módulo-04-Directivas-Clase-02-Directivas de atributo
Módulo-04-Directivas-Clase-03-Directivas estructurales

Módulo-05-Pipes-Clase-01-Qué son los pipes 
Módulo-05-Pipes-Clase-02-Creando nuestro Pipe -Pipe Vs Funciones

Módulo-06-Rutas-Clase-01-Qué son los módulos
Módulo-06-Rutas-Clase-02-Rutas
Módulo-06-Rutas-Clase-03-Rutas con hijos
Módulo-06-Rutas-Clase-04-Guards
Módulo-06-Rutas-Clase-05-Aplicando lazy loading en rutas

Módulo-07-Forms-Clase-01-Forms-FormControl
Módulo-07-Forms-Clase-02-FormGroups

Módulo-08-Forms-Clase-01-Arquitectura de servicios en Angular
Módulo-08-Forms-Clase-02-Servicios en Angular (petición get)
Módulo-08-Forms-Clase-03-HTTP-Petición GET con params
Módulo-08-Forms-Clase-04-HTTP-Petición POST,PUT,DELETE
Módulo-08-Forms-Clase-05-HTTP-Interceptores

Módulo-09-RxJS-Clase-01-Introducción a RxJS
Módulo-09-RxJS-Clase-02-RxJS-Casos prácticos
Módulo-09-RxJS-Clase-03-RxJS-Operadores

Módulo-10-ProyectoFinal-Clase-01-Demostración del proyecto final
Módulo-10-ProyectoFinal-Clase-02-Estructura del proyecto
Módulo-10-ProyectoFinal-Clase-03-Wireframes del proyecto
Módulo-10-ProyectoFinal-Clase-04-Listado-Creando los componentes
Módulo-10-ProyectoFinal-Clase-05-Listado-Funcionalidad del listado
Módulo-10-ProyectoFinal-Clase-06-Listado-Agregando scroll infinito
Módulo-10-ProyectoFinal-Clase-07-Listado-Agregando filtrado
Módulo-10-ProyectoFinal-Clase-08-Detalle-Creando los componentes
Módulo-10-ProyectoFinal-Clase-09-Detalle-Funcionalidad

******************************************************************************
******************************************************************************

Curso Profesional de Angular (Código Facilito) (19/04/2023)

$ ng new 0012-curso-profesional-angular

***************************************** COMPONENTES:
$ cd 0012-curso-profesional-angular
$ ng g c directiva-atributo
$ ng g c directiva-estructural
$ ng serve -o


git add .
git commit -m "Curso Profesional de Angular (Código Facilito) (19/04/2023). Inicio"

--Crear el repositorio en GitHub
git remote add origin https://github.com/RenegadeAsturias/0012-curso-profesional-angular.git
git push origin main

***************************************** PIPES:
$ ng g c pipes

Documentación de pipes:
https://angular.io/guide/pipes
https://angular.io/api/common/DatePipe

$ ng g pipe pipes/estados


***************************************** RUTAS:
(1) ¿Qué son los módulos?
Agrupación de componentes por funcionalidad.

(2) Rutas
(3) Rutas con hijos
(4) Guards
(5) Aplicando lazy loading en rutas

$ ng g m compra

#¡Ojo! Para que me añada los nuevos componentes
#al módulo 'compra' (ej:UPDATE src/app/compra/compra.module.ts)
$ cd src/app/compra

$ ng g c listado
CREATE src/app/compra/listado/listado.component.html (22 bytes)
CREATE src/app/compra/listado/listado.component.spec.ts (606 bytes)
CREATE src/app/compra/listado/listado.component.ts (206 bytes)
CREATE src/app/compra/listado/listado.component.css (0 bytes)
UPDATE src/app/compra/compra.module.ts (278 bytes)

$ ng g c nuevaCompra
$ ng g c historialCompra

@NgModule({
  declarations: [
    ListadoComponent, ************** Componente 'listado' actualizado
    NuevaCompraComponent, ********** Componente 'nuevaCompra' actualizado
    HistorialCompraComponent ******* Componente 'historialCompra' actualizado
  ],
  imports: [
    CommonModule
  ]
})
export class CompraModule { }


************************************************************
#Ahora quiero utilizar uno de mis nuevos componentes del módulo 'compra'
#Y en 'app.component.html' añado el selector: 'app-listado',

<h1>Listado de Compras</h1>
<app-listado></app-listado>

#Pero el compilador me da error
'app-listado' is not a known element:
1. If 'app-listado' is an Angular component, then verify that it is part of this module.

#Aún no puedo utilizar el módulo 'compra' tengo que registrarlo en:
scr > app > app.module.ts

@NgModule({
  declarations: [
    AppComponent,
    DirectivaAtributoComponent,
    DirectivaEstructuralComponent,
    PipesComponent,
    EstadosPipe
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    CompraModule ******************* Módulo 'compra' registrado
  ],
... ... ... ...

#El error persiste:
'app-listado' is not a known element:
1. If 'app-listado' is an Angular component, then verify that it is part of this module.

#Los Componentes están registrados en el módulo 'compra'
#pero son propios de este módulo y por defecto
#otros módulos no pueden utilizarlos como en este caso
#porque puede ser que en realidad queramos eso, que nuestros componentes
#sólo deben ser vistos por un componente y no sean vistos por el resto de módulos.
#Para solucionarlo, en el módulo 'compra' hay que exportar
#los componentes que pueden ser vistos por otros módulos:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],
  exports: [
    ListadoComponent  ********* Exportar los componentes
                      ********* visibles para otros módulos
  ],
  imports: [
    CommonModule
  ]
})
export class CompraModule { }

#Ahora ya funciona correctamente la llamada al componente:
<h1>Listado de Compras</h1>
<app-listado></app-listado>
√ Compiled successfully.


#Entonces como el componente del módulo 'compra': NuevaCompraComponent
#no ha sido exportado no podría hacer:
src > app > app.component.html
<h1>Nueva Compra</h1>
<app-nueva-compra></app-nueva-compra>

#Pero si podría utilizarlo dentro de los componentes
#correspondientes al módulo 'compra'.
#Esto funciona:
src > app > compra > listado > listado.component.html
<h1>Nueva Compra</h1>
<app-nueva-compra></app-nueva-compra>

******************************************************************
Creamos un nuevo módulo que va a trabajar con la ruta de nuestro proyecto:
$ ng g m AppRouting
CREATE src/app/app-routing/app-routing.module.ts

Como yo ya había creado el proyecto y le dije que habilitase Routing Y
ya tengo creado el módulo para las rutas en:

src > app > app-routing.module.ts

Tendremos esto:

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

------------------------------------------------------------

#Añadimos las rutas en:
const routes: Routes = [
    {path: 'pipes', PipesComponent: }
];

Para que funcione, tecleamos en la url del navegador
http://localhost:4200/pipes

Pero aún no se muestra nada, nos vamos:

src > app > app.component.hml

Comentamos todo lo que teníamos y añadimos:

<router-outlet></router-outlet>

ahora volvemos a escribir:
src > app > app.component.hml

Y ya vemos el contenido de nuestro componente:
scr > app > pipes > pipes.component.html
desplegado en el contenedor:
<router-outlet></router-outlet>

Pipe titlecase: René
Pipe upppercase: RENÉ
Pipe date: Feb 20, 2020

------------------------------------------------------------

#Añadimos otra ruta en:
const routes: Routes = [
  {path: 'pipes', component: PipesComponent},
  {path: 'estructural', component: DirectivaEstructuralComponent}
];

Para que funcione, tecleamos en la url del navegador
http://localhost:4200/esctructural

------------------------------------------------------------

Vamos a implementar un botón para ir
desde la página de Pipes para ir a Estructural:

<button [routerLink]="['/estructural']">Ir a Componente Estructural</button>

Y ahora añadimos otro nuevo botón
y vemos el atributo: routerLinkActive
que nos ayuda a identificar la ruta activa
y le asociamos un estilo para que se identifique que estamos en ella.

<button [routerLink]="['/estructural']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<button [routerLink]="['/pipes']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>

------------------------------------------------------------

Cambimos de lugar los botones de cambios de rutas para que nos sirvan
en modo navegación, en:

src > app > app.component.html

<button [routerLink]="['/estructural']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<button [routerLink]="['/pipes']" routerLinkActive="seccionActiva">Ir a Componente Estructural</button>
<router-outlet></router-outlet>


------------------------------------------------------------

Rutas con hijos:

1.-En el módulo de compras tenemos declaradas los siguientes componentes:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],

Y vamos a seleccionar el: ListadoComponent 
como el contenedor de todo el módulo de compras:

Así que voy a añadir la ruta padre con: ListadoComponent
y las rutas hijas con el resto de componentes.
De momento tenemos solo estas rutas definidas:

const routes: Routes = [
  {path: 'pipes', component: PipesComponent},
  {path: 'estructural', component: DirectivaEstructuralComponent}
];

Añadimos las rutas:
const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', component: ListadoComponent, children: [
		{ path: 'nueva', component: NuevaCompraComponent },
		{ path: 'historial', component: HistorialCompraComponent },
	]}
];

Para poder utilizar las Rutas en nuestro módulo de compras
tenemos que añadir el 'RouterModule' al módulo:

@NgModule({
  declarations: [
    ListadoComponent,
    NuevaCompraComponent,
    HistorialCompraComponent
  ],
  exports: [
    ListadoComponent
  ],
  imports: [
    CommonModule,
	RouterModule ************** Para poder utilizar las rutas en el módulo de compras
  ]
})
export class CompraModule { }

Ahora vamos a configurar una navegación para nuestro módulo de compras:

src > app > compra > listado.component.html

<button [routerLink]="['/compra/nueva']" routerLinkActive="seccionActiva">Nueva compra</button>
<button [routerLink]="['/compra/historial']" routerLinkActive="seccionActiva">Historial compra</button>
<router-outlet></router-outlet>


------------------------------------------------------------
--------------- Ruta por defecto ---------------------------

Configuramos la Ruta por defecto para cuando no haya una ruta
por ejemplo, cuando entramos inicialmente en la aplicación

http://localhost:4200

Añadimos la ruta:
const routes: Routes = [
	... ... ... ... ..., 
	{ path: '', redirectTo: 'pipes', pathMatch: 'full' }
];

De esta forma cuando introduccimos en la Url del navegador:
http://localhost:4200

Nos redirecciona a:
http://localhost:4200/pipes


------------------------------------------------------------
--------------- Guards -------------------------------------

Comenzamos a ver Guards
que son filtros o funciones que podemos añadir a una ruta para que
por ejemplo se valide algo antes de acceder a la ruta:

$ ng g guard auth

Y el menú de opciones nos solicita que tipo de Guard queremos crear:

$ ng g guard auth
? Which type of guard would you like to create? (Press <space> to select, <a> to toggle all, <i> to invert selection, and
<enter> to proceed)
>(*) CanActivate
 ( ) CanActivateChild
 ( ) CanDeactivate
 ( ) CanLoad
 ( ) CanMatch

Selecciono el valor por defecto:
>(*) CanActivate

Y nos crea estos dos ficheros:
CREATE src/app/auth.guard.spec.ts (331 bytes) ******* Para pruebas
CREATE src/app/auth.guard.ts (457 bytes) ************ Para la lógica que verifica si puedo acceder

que nos permite saber si podemos acceder a una ruta.

Los guards no se actualizan dentro de ningún módulo
ni necesitan estar dentro de ningún módulo.

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
	
	// Debajo de los dos parámetros que recibe el método
	// Introducimos la lógica de negocio que verifica si accedemos o no
	// Como valor devuelto más típico, devolvemos un booleano.
	
    return true;
  }
  
}

Para un ejemplo, simulando una autenticación definimos en:

src > app > app.component.ts

export class AppComponent {

	constructor() { // Simulamos el Id del usuario.
		localStorage.setItem('id', '1234');
	}

Y ahora implementamos la comprobación en nuestro Guard auth:

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
	
	const id = localStorage.getItem('id');
    return id === '1234';
  }
  
}

De momento solo lo hemos definido pero no lo hemos utilizado.
Vamos a nuestro módulo de rutas:

src > app > app-routing.module.ts

Y lo anexado a la ruta que deseamos proteger:

La ruta que deseamos proteger en este caso es 'compra'
Le añadimos un atributo nuevo: canActivate
y como valores le asignamos un array con los Guards
que quiero que anexar a la ruta.

Añadimos los Guards a la ruta:

import { AuthGuard } from './auth.guard';

const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard], ****************** Guard anexado
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard],
		children: [
			{ path: 'nueva', component: NuevaCompraComponent },
			{ path: 'historial', component: HistorialCompraComponent },
		]
	}
];

Para probar que funciona añadimos un nuevo botón a nuestra cabecera de navegación:

src > app > app.component.html

<button [routerLink]="['/compra']" routerLinkActive="seccionActiva">Ir a Compras</button>

Y hacemos clic en el botón 'Ir a Compras' y vemos que nos lleva correctamente
a la ruta '/compras' que habíamos protegido con nuestro Guard
porque el identificador del usuario de la validación coincide con '1234'
y el Guard está pasando como true.


Ahora vamos a guardar inicialmente otro identificador diferente
en el localStorage para que el Guard no valide la condicón a true:

src > app > app.component.ts

export class AppComponent {

	constructor() { // Simulamos el Id del usuario.
		localStorage.setItem('id', '9999');
	}
	

-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-06-Rutas-Clase-05-Aplicando lazy loading en rutas

Hemos estado trabajando con rutas en el módulo anterior
y tenemos un montón de rutas definidas en nuestro proyecto.
y eso está bastante bien pero lo que pasa con las Single Page Application (SPA)
es que solo cargan una vez todos los módulos 
y después el usuario puede recorrer entre ellos sin necesidad
de que la página se recargue.

El problema puede surgir si nuestra aplicación tiene
muchas páginas, muchas rutas y muchos módulos
la carga inicial de nuestra aplicación puede ser un poco lenta.
Así que dependiendo del número de módulos de nuestra aplicación
en algún punto no es viable está cargando todo en el inicio.

Porque en la mayoría de los casos los usuarios no van a utilizar
todas las rutas que tenemos definidas en nuestro proyecto.
Por lo que no sirve de nada relentizar la carga inicial de la página
por cargar módulos que el usuario no va a utilizar.

La solución para este problema se llama: lazy loading
es decir, carga perezosa que es una estrategia para descargar
de manera perezosa o en otras palabras a demanda
algunos módulos que nosotros queramos cargar así.

Por ejemplo, si nuestra aplicación tiene 10 módulos
pero los que más utilizan todos los usuarios son dos
los podemos cargar en el inicio de la aplicación
y los demás van a cargar cuando el usuario intente entrar
en la ruta de cada módulo.

De este modo la carga inicial será más rápida
y cuando usuario intenté entrar a la ruta de un módulo no cargaddo
se va a descargar toda la lógica de este módulo.

Vamos a crear en nuestra aplicación de ejemplo
un nuevo módulo de venta y que tenga lazy loading implementado.

Creamos el módulo de venta:
$ ng g m venta --routing=true

CREATE src/app/venta/venta-routing.module.ts (248 bytes)
CREATE src/app/venta/venta.module.ts (276 bytes)

Nos crea un fichero extra, para manejar las rutas de nuestro
nuevo módulo de manera encapsulada:

src/app/venta/venta-routing.module.ts

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';

const routes: Routes = [];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule]
})
export class VentaRoutingModule { }


---------- Añadimos unos componentes para nuestro módulo de venta -----------
con el mismo nombre que nuestros componentes del módulo de compra
pero que estén dentro de la carpeta 'venta'

$ ng g c venta/listado
CREATE src/app/venta/listado/listado.component.html (22 bytes)
CREATE src/app/venta/listado/listado.component.spec.ts (606 bytes)
CREATE src/app/venta/listado/listado.component.ts (206 bytes)
CREATE src/app/venta/listado/listado.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (364 bytes)

$ ng g c venta/historial-venta
CREATE src/app/venta/historial-venta/historial-venta.component.html (30 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.spec.ts (656 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.ts (237 bytes)
CREATE src/app/venta/historial-venta/historial-venta.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (480 bytes)

$ ng g c venta/nueva-venta
CREATE src/app/venta/nueva-venta/nueva-venta.component.html (26 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.spec.ts (628 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.ts (221 bytes)
CREATE src/app/venta/nueva-venta/nueva-venta.component.css (0 bytes)
UPDATE src/app/venta/venta.module.ts (580 bytes)


En nuestro nuevo módulo de ventas, añadimos las nuevas rutas:

src > app > venta > venta-routing.module.ts

import { NuevaVentaComponent } from './nueva-venta/nueva-venta.component';
import { HistorialVentaComponent } from './historial-venta/historial-venta.component';

const routes: Routes = [{
	path: '',
	children: [
		{ path: '', redirectTo: 'nueva', pathMatch: 'full' },
		{ path: 'nueva', component: NuevaVentaComponent },
		{ path: 'historial', component: HistorialVentaComponent },
	],
}];
	
Hemos creado un nuevo módulo y tenemos que añadirlo al fichero:

src > app > app.module.ts

import { VentaModule } from './venta/venta.module';

@NgModule({
  declarations: [
    AppComponent,
	... ... ... ...
  ],
  imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule,
    CompraModule,
    VentaModule ************ Incluimos en nuevo módulo venta   
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

Anora vamos a añadir una nueva ruta pero en nuestro fichero:

src > app > app-routing.module.ts

const routes: Routes = [
	... ... ... ... ..., 
	{ path: 'compra', 
		component: ListadoComponent, 
		canActivate: [AuthGuard],
		children: [
			{ path: 'nueva', component: NuevaCompraComponent },
			{ path: 'historial', component: HistorialCompraComponent },
		]
	},
	{ path: 'venta', ********************* Nueva Ruta
		loadChildren: () => 
			import('./venta/venta.module').then((m) => m.VentaModule),
	},
];

Para que se carguen el módulo de venta tendremos que ir a la url
del navegador e introducir: http://localhost:4200/venta

Desde las herramientas de desarrollo del Chrome vemos como ahora
se descarga el módulo de venta.


-------------------------------------------------------------------------
-------------------------------------------------------------------------
Módulo-07-Forms-Clase-01-Forms-FormControl

Creando y gestionando formularios con Angular
Existen dos tipos de manejos de formularios:
-Formuarios por template
-Formularios reactivos

Creamos un nuevo repositorio para ver los formularios

$ ng new 0014-curso-profesional-angular-formularios

Creamos un nuevo componente:
(con --skip-test no se creará el fichero de test)

Creamos un componente para crear formularios reactivos
$ ng g c formularios --skip-tests

Y también creamos un nuevo componente para crear botones
de navegación:
$ ng g c cabecera --skip-tests

#Añadimos la ruta para el componente formularios en:
const routes: Routes = [
	{ path: '', redirectTo: 'formularios', pathMatch: 'full' }
    { path: '/formularios', component: FormulariosComponent  }
];

Pero aún no se muestra nada, nos vamos a:
src > app > app.component.hml

Y añadimos
<app-cabecera></app-cabecera>
<router-outlet></router-outlet>

En el template del componente cabecera añadimos al menos un botón:
<button [routerLink]="['/formularios']" routerLinkActive="seccionActiva">Ir a Formularios</button>
<hr>

Para poder utilizar los formularios reactivos añadimos el módulo: ReactiveFormsModule en:

scr > app > app.module.ts

Añadimos:

import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  declarations: [
    AppComponent,
    CabeceraComponent,
    FormulariosComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    ReactiveFormsModule ******** Formularios Reactivos


Ahora vamos a añadir un control que estará asociado o tendrá un binding
a una varible del formulario:

scr > app > formularios > formularios.component.ts

import { FormControl } from '@angular/forms';

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('');
}

scr > app > formularios > formularios.component.html

<input type="text" placeholder="Nombre" [formControl]="name">
{{name.value}} // Incluímos una interpolación para ver el valor de la variable del input

+Añadimos otro campo:

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('');
  isChecked = new FormControl(false);
}

<input type="checkbox" [formControl]="isChecked"/>
{{isChecked.value}}

Para visualizar un objeto y sus propiedades por pantalla
por ejemplo para depuración podemos escribir:

<pre>
	<code>
		{{isChecked | json}}
	</code>
</pre>

------------- Añadimos Validators ----------------------------------

Por ejemplo, añadimos Validators al campo name:

@Component({ ...
export class FormulariosComponent {
  name = new FormControl('', [Validators.minLength(4), Validators.required]);

Y también añadimos en el template la sintaxis anterior para ver el objeto
y las validaciones y sus estados cuando utilizamos el campo:

<pre>
	<code>
		{{name | json}}
	</code>
</pre>

Ahora vamos a añadir un nuevo botón que esté deshabilido si hay errores
en el campo nombre y habilitado si no hay errores:

<button [disabled]="name.errors">Enviar</button>




