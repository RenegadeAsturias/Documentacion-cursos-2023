
Apuntes-Angular. Curso Angular Avanzado (LinkedIn Learning) (2023)

0.Introducción
1.Presentación

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Preparación de las bases del proyecto
-------------------------------------------------------------

$ ng new componentesAvanzados

#Como preparación del proyecto nos propone:

#1 Incluir un framework de trabajo para css
<link rel="stylesheet" 
href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.css"/>

#2 Añadimos unas imágenes en la carpeta assets del proyecto:
src > app > products > mineralwater-orange.jpg
src > app > products > mineralwater-strawberry.jpg
src > app > products > proteinbar-chocolate.jpg

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Instalar modelos, interfaces y componentes base
-------------------------------------------------------------

#1 Definimos una clase (modelo)
$ ng generate class models/tienda.model
$ CREATE src/app/models/tienda.model.spec.ts
$ CREATE src/app/models/tienda.model.ts

#Entramos en la clase y le cambiamos el nombre (le quitamos el models)
#y se queda:
export class Tienda { }

#Ahora definimos el modelo:
export class Tienda { 

	// Definimos un array para guardar los Items de mi tienda
	tiendaItems:Array<Object>
	
	constructor(){
		// Cargamos el array con los Items de mi tienda
		this.tiendaItems = [
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "mineralwater-orange.jpg",
			precio: 20
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Strawberry Mineral Water ",
			imagen: "mineralwater-strawberry.jpg",
			precio: 33
			},
			{
			texto: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed...",
			titulo: 'Orange Mineral Water ",
			imagen: "proteinbar-chocolate.jpg",
			precio: 120
			}
		];
	}

}

#Ahora creamos un interface que defina la estructura del modelo

$ ng generate interface interfaces/Producto
CREATE src/app/interfaces/producto.ts

#Entramos en el interface y lo definimos:

export interface Producto {
	precio?: number;
	titulo?: string;
	imagen?: string;
	texto?:  string;
}

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Qué son los componentes statefull y staleless
-------------------------------------------------------------

#Los componentes statefull
son los componentes que contienen información, operaciones
y posíblemente otros componentes staleless


#Los componentes staleless
son componentes que no contienen un estado
en general son componentes simples
que lo que hacen es desplegar información

#1 Vamos a crear un componente statefull
$ ng generate component con-estado

#2 Vamos la plantilla de componente principal
src > app > app.component.html

#3 Incluimos dentro el componente que hemos creado
<app-con-estado></app-con-estado>

#4 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts

#Importamos el interface y el modelo
import { Producto } from "../interfaces/producto";
import { Tienda } from "../models/tienda.model";

#Creamos dos variables en la clase
export class ConEstadoComponent implements OnInit {
	modeloTienda:Tienda = new Tienda();
	itemsComprados:Array<Producto>;

#5 Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		{{item.titulo}}
		<!----------- --------------->
	</div>
</div>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes statefull
-------------------------------------------------------------

#Un componente statefull tiene la capacidad de almacenar información
y en algunos casos incluso de procesarla.

#1 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Estoy mostrando un listado de productos y aparece un botón de comprar el producto en su ficha.
#Al hacer clic capturamos el item mostrasdo en cada caso.
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#2 Editamos la clase de nuestro componente con-estado
src > app > con-estado > con-estado.component.ts
#Implementamos el método que se invoca en el evento clic: seleccionarItem(item)

export class ConEstadoComponent implements OnInit {

modeloTienda:Tienda = new Tienda();
itemsComprados:Array<Producto>;

constructor() {
	this.itemsComprados=[]; // Inicializamos el Array
}

seleccionarItem(item) {
	this.itemsComprados.push(item);
}

#3 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Vamos a mostrar también el array con la lista de items comprados
#Así desplegamos un componente de tipo statefull
<section>
	<li *ngFor="let itemComprado of itemsComprados">{{itemComprado.titulo}}</li>
</section>

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Conociendo los componentes stateless
-------------------------------------------------------------

#Un es un componente que solo despliega datos
#Y si realiza algún proceso será un proceso interno que no variables
#a afectar a esos datos.

#1 Creamos un componente sin estado
$ ng generate component sin-estado

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Vamos a copiar el código HTML que mostraba la información
#de cada uno de los items que estábamos mostrando antes
#en la plantilla del componente con estado:

<!----------- --------------->
{{item.titulo}}
<!----------- --------------->

<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#3 Vamos de nuevo al componente principal donde ahora
#vamos a tener una relación padre-hijo
#incluyendo en él el componente sin-estado

#Editamos la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		<app-sin-estado></app-sin-estado> .......Incluimos el componente hijo
		<!----------- --------------->
	</div>
</div>

#Ojo! Que se muestra la plantilla pero no se visualiza la información
#ésto lo solucionaremos en la próxima sección

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Captura de datos con @Input
-------------------------------------------------------------

#La relación que se establece entre un componente con estado (statefull)
#y un componente sin estado (stateless)
#es prácticamente indispensable que el componente staleless reciba información
#del componente statefull

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir

import { Producto } from "../../interfaces/producto";

#La nomenglatura: @Input() permite exponer o inyectar información
#en este ejemplo vamos a recibir un objeto de tipo Producto

export class SinEstadoComponent implements OnInit {

	@Input() producto: Producto;


#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html

#Cambiamos todas las notaciones de referencia al objeto
#que teníamos cuando estaba acoplada al componente statefull
#ahora nuestro objeto es: producto

{{item.precio}} -----> {{producto.precio}}
{{item.titulo}} -----> {{producto.titulo}}
{{item.imagen}} -----> {{producto.imagen}}
{{item.texto}} ------> {{producto.texto}}

#3 Ahora nos queda decirle a nuestro componente padre (statefull)
#que puede enviarnos información sobre el item sobre el que estamos trabajando
#Modificamos en la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
... ... ...
<h1 class="title">PRODUCTOS</h1>
<div class="columns">
	<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
		<!----------- --------------->
		
		#Añadimos [producto]="item"
		#esto inyecta en nuestro componente hijo sin estado (staleless)
		#en nuestro @Input() producto el item en curso
		
		<app-sin-estado [producto]="item"></app-sin-estado>
		<!----------- --------------->
	</div>
</div>

#En resumen el componente padre (statefull) que tiene toda la información
#inyecta y pasa inforación a su componente hijo (staleless) 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Lógica interna de un componente staleless
-------------------------------------------------------------

#El objetivo principal de utilizar componentes stateless
#es mantener nuestra lógica distribuída y funcional.
#Podemos utilizar procedimientos internos siempre y cuando permanezcan encapsulados.

#1 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a añadir dos propiedades

export class SinEstadoComponent implements OnInit {
@Input() producto: Producto;

private disabled:boolean;
public accionCompra:string;

#Incializamos el valor de una de las variables

#Ojo!!! queremos inicialiar la variable con la siguiente sintaxis:
this.accionCompra = `BUY FOR € ${this.producto.precio}´};

#Quizás podríamos pensar en colocarlo en el constructor
constructor() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#O quizás podríamos pensar en colocarlo en el ngOnInit() 
ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

#Explicación de dónde debería ir y por qué:

#Si lo ponemos en el constructor vamos a tener un problema
#El constructor va a estar definido en el momento en el que se crea nuestra aplicación
#pero no en el momento en que invocamos nuestro componente.

#El código debería incluirse en el ngOnInit para que funcione correctamente
#El ngOnInit nos va desplegar los datos en el momento en que este componente está disponible.
#cuando ya tenemos acceso a los valores de Producto o Precio.

#2 En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
... ... ... ... ...
<button class="button" (click)="seleccionarItem(item)" >
BUY FOR {{item.precio}}€
</button>

#Reemplazamos el código que teníamos anteriormente:
BUY FOR € ${this.producto.precio}

#Por la nueva variable que ahora tiene el mismo valor
<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>


#3 Nos damos cuenta también que cuando movimos el código
#del componente padre con-estado (statefull) con todos los datos
#al componente hijo sin-estado (staleless)
#El siguiente código que manejaba el evento click perdió su funcionalidad:

<button class="button" (click)="seleccionarItem(item)" >
	{{accionCompra}} 
</button>

#Cambiamos en la plantilla el código anterior por:
<button class="button" (click)="seleccionarItem()" >
	{{accionCompra}} 
</button>

#4 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar de nuevo el método:

export class SinEstadoComponent implements OnInit {

private disabled:boolean;
public accionCompra:string;

ngOnInit() {
	this.accionCompra = `BUY FOR € ${this.producto.precio}´};
}

seleccionarItem() {
	this.disabled = true; // Por defecto en su definición es false
	this.accionCompra = "AÑADIDO AL CARRITO!";
}

#5 Vamos a cambiar un poco más el componente y vamos a aprovechar la variable disabled
#En la plantilla del componente sin estado
src > app > sin-estado > sin-estado.component.html
#Utilizamos la sintaxis [<propiedad_de_HTML>] para definir su valor
#Por ejemplo:

#La propiedad HTML disabled del botón tomará su valor del método
<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()" 
>
	{{accionCompra}} 
</button>

#6 En la clase del componente sin estado
src > app > sin-estado > sin-estado.component.ts
#Vamos a implementar el nuevo método

isItemDisabled() {
	return !this.disabled;
}

#7 Un último cambio, vamos a añadir una clase css al botón
#utlizando la siguiente sintaxis:

#La propiedad HTML disabled del botón tomará su valor del método
#Si el producto no ha sido comprado y por tanto el botón no está disabled
#se le añadirá una clases que haga más llamativo el botón de comprar
#y se traduciría por algo así: <button class"button is-danger"...

<button class="button" (click)="seleccionarItem()" 
	[disabled]="isItemDisable()"
	[ngClass]="{'is-danger':!isItemDisabled()}"
>
	{{accionCompra}} 
</button>

#Estamos realizando cálculos, realizando procesos dentro de nuestro componente
#pero en ningún caso afectan a los valores... no estamos cambiando los precios,
#no estamos cambiando ningún estado...
#Cada uno de los componentes staleless se mantiene completamente encapsulado 


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Envío de enventos con @Output
-------------------------------------------------------------

#Estamos trabajando con un componente padre statefull
#y tres componentes hijos staleless

#Desde el componente padre statefull estamos inyectando información
#a los componentes hijos staleless

#Para hacer esto hemos declarado en el clase del componente hijo
#la siguiente declaración: @Input() producto: Producto;

#Tendríamos:
export class SinEstadoComponent implements OnInit {
	@Input() producto: Producto;

#Y ahora el componente padre inyecta información
#a través de ese objeto, en la llamada al componente hijo
#Añadimos [producto]="item"
#esto inyecta en nuestro componente hijo sin estado (staleless)
#en nuestro @Input() producto el item en curso

<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
<!----------- --------------->
	<app-sin-estado [producto]="item"></app-sin-estado>


#Ahora vamos enviarle información desde los componentes hijos statefull
#al componente padre staleless para que modifique los datos

#La forma en que vamos a interactuar entre estos dos elementos
#es a partir de los eventos.
#Entonces, el componente hijo, cuando reciba algún tipo de cambio relevante
#en este caso, cuando se le hace clic a un botón
#va a avisar al padre que hubo una interacción del usuario
#y que es posible que necesitemos modificar los datos
#pero nunca el componente sin-estado stateless tiene que realizar esos cambios
#y todo lo que ocurra dentro del componente con estado debe estar encapsulado.

#1 En la clase del componente sin-estado
Añadir al import: EventEmitter y asegurarse que apunta al '@angular/core'

import { Component, OnInit, Input, Output, EventEmitter } from "@angular/core";

@Input producto: Producto;

#Esto es un emisor de eventos que nos permite enviar información al padre
@Output productoSeleccionado: EventEmitter<Producto> = new EventEmitter()

#2 Vamos a reutilizar el evento que tenemos definido en los componentes stateless

<button class="button" (click)="seleccionarItem()" -->Definido en el clic del botón

#En la implementación del método añadimos lo siguiente para despachar el evento
#emitiremos un evento de tipo producto
seleccionarItem() {
	this.disabled = true; // Por defecto en su definición es false
	this.accionCompra = "AÑADIDO AL CARRITO!";
	#Para el evento:________________________________
	this.productoSeleccionado.emit(this.producto)
}

#3 Ahora implementamos la captura del evento
#para capturarlo cada vez que se despache cuando ocurra el evento.
#En Angular siempre capturamos los eventos a partir de los paréntesis.
#En la plantilla del componente padre statefull añadimos:

<div class="column" *ngFor="let item of modeloTienda.tiendaItems">
<!----------- --------------->
	<app-sin-estado 
		[producto]="item"
		# Para el evento:________________________________
		(productoSeleccionado)="onProductoSeleccionado($event)"
	>
	</app-sin-estado>
	
#4 Ahora en la clase del componente padre statefull implementamos el método:
onProductoSeleccionado(_event: Producto){
	console.log(_event);
}

#5 Ahora hacemos clic sobre uno de los botones de un componente disparando el evento.
#Ahora podemos ver en la consola del navegador cómo se ha despachado un evento producto
#y lo hemos capturado correctamente.
#Se imprime en la consola la información del producto sobre el que hicimos clic.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
2. Componentes statefull y staleless
+Integración de componentes statefull con componentes staleless
-------------------------------------------------------------

#1 Retomamos el ejemplo anterior y cambiamos el console.log
#por una llamada a un método que ya teníamos implementado:

seleccionarItem(item) {
	this.itemsComprados.push(item);
}

onProductoSeleccionado(_event: Producto){
	seleccionarItem(_event);
}

#2 En la plantilla de nuestro componente con-estado
src > app > con-estado > con-estado.component.html
#Mostrábamos también el array con la lista de items comprados
<section>
	<li *ngFor="let itemComprado of itemsComprados">{{itemComprado.titulo}}</li>
</section>

#3 Retocamos la plantilla de nuestro componente con-estado
en el apartado anterior para mostrar mejor la información
Mostramos el título y a su derecha el precio del producto
<section>
	<li *ngFor="let itemComprado of itemsComprados">
		Título:{{itemComprado.titulo}}<br/>
		Precio:{{itemComprado.precio | currency}}
	</li>
</section>

#4 Añadimos también un campo con el total de todos los productos comprados
<br>Total comprados: {{getPrecioTotal() | currency }}

#5 Implementamos en la clase del componente padre statefull
#el método para sumar los productos comprados

getPrecioTotal(){
	if(this.itemsComprados){
		return this.itemsComprados.reduce(
			(prev:number,item:Producto) => prev + item.precio, 0);
		);
	}
}

#6 Un cambio más. Para que no se vea el contenido de la sección vacía
#si aún no hemos comprado componentes hacemos la siguiente modificación

<section>
	<div *ngIf="itemsComprados.length > 0">
		<p>Listado de elementos comprados</p>
		<li *ngFor="let itemComprado of itemsComprados">
			Título:{{itemComprado.titulo}}<br/>
			Precio:{{itemComprado.precio | currency}}
		</li>
	</div>
</section>


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Interacción entre componentes
+Control de componentes anidados con @viewChild
-------------------------------------------------------------

#Debajo del listado de items comprados vamos a tener un botón 'Buy now!'
#y queremos que cuando haga clic me aparezca una ventana de confirmación

#Creamos un nuevo componente:
$ ng generate component alerta-confirmacion

#En la clase del nuevo componente añadimos:
export class AlertaConfirmacionComponent {
	public active:Boolean;
	constructor(){
		this.active = true;
	}
	ocultar() {
		this.active = false;
	}
}

#Vamos a añadir este componente al componente padre: 
#con-estado.component.html

<app-alerta-confirmacion></app-alerta-confirmacion>

#Ahora vamos a generar una ventana modal
#Inicialmente en el proyecto incluimos Bulma:

#1 Incluir un framework de trabajo para css
<link rel="stylesheet" 
href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.5/css/bulma.css"/>

#Esto nos ayuda a crear un plantilla que es una ventana modal:

<div class="modal" [ngClass]="{'is-active':active}">
    <div class="modal-background"></div>
    <div class="modal-card">
        <header class="modal-card-head">
            <p class="modal-card-title">Modal title</p>
            <button class="delete" aria-label="close" (click)="ocultar()"></button>
        </header>
        <section class="modal-card-body">
            Content ...
        </section>
        <footer class="modal-card-foot">
            <button class="button is-success">Save changes</button>
            <button class="button" (click)="ocultar()">Cancel</button>
        </footer>
    </div>
</div>

#Y en la clase del componente de la ventana modal: alerta-confirmacion.component.ts
#De momento tenemos:

export class AlertaConfirmacionComponent {
	public active:Boolean;
	constructor(){
		this.active = false; // Por defecto el componente no se muestra
	}
	ocultar() { // Se oculta con los botones de cerrar y cancelar de la ventana modal
		this.active = false;
	}
	mostrar() { // Y aún está pendiente llamar para mostrar
		this.active = true;
	}
}

#Explicación:

#En la plantilla del componente padre, con-estado.component.html
#tenemos la implementación del botón de comprar:
#Y el componente anidado o componente hijo:
<button class="button" 
	(click)="realizarPago()"
	[disabled]="noHayItemsComprados()">BUY NOW!
</button>
<app-alerta-confirmacion></app-alerta-confirmacion>

#Y en la clase del componente padre, con-estado.component.ts
#tenemos la implementación del método: realizarPago()

#Este método va a tratar de controlar el componente anidado
#o el componente hijo:
<app-alerta-confirmacion></app-alerta-confirmacion>

#Lo hacemos a través de una propiedad @ViewChild
#ViewChild básicamente expone los componentes que se encuentran
#dentro de un componente hijo

#Añadimos a la clase del componente padre, con-estado.component.ts

@ViewChild(AlertaConfirmacionComponent, {static:false})

#Y ahora importamos los componentes:
import { AlertaConfirmacionComponent } from "./../alerta-confirmacion/alerta-confirmacion-component";
import { Component, OnInit, ViewChild } from "@angular/core";

#Y ahora creamos una instancia del componente:
@ViewChild(AlertaConfirmacionComponent, {static:false})
alertChild:AlertaConfirmacionComponent;

#Ya tenemos las bases para controlar el componente hijo
#sin acceder directamente a él

#Retomamos la implementación del método:
getPrecioTotal(){
	// this.alertChild. -->Esto nos da acceso a todo el componente y a todos sus métdos.
	this.alertChild.mostrar(); // Para mostrar el componente
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
3. Interacción entre componentes
+Estrategias de detección de cambios
-------------------------------------------------------------

#En esta lección aprenderemos que son y cómo podemos administrar 
#los controles de cambios dentro de Angular
#En nuestra aplicación actual tenemos tres diferentes niveles de anidado.

#Control de cambios
#Vamos al componente que gestiona los productos: sin-estado.component.ts
#Lo que vamos a hacer es que le vamos a declarar
#una política o una estrategia de control de cambios.

#Añadimos en el decorador:
import { ..., EventEmitter, ChangeDetectionStrategy } from "@angular/core"

@Component({ ...
	#Tenemos dos diferentes políticas: Default, que es la que tenemos por defecto
	#changeDetection: ChangeDetectionStrategy.Default
	#Con esta estrategia: la aplicación estaba invocando los métodos 
	#de todos los componentes y de los hijos de esos componentes a su vez
	
	#Tenemos dos diferentes políticas: OnPush
	#changeDetection: ChangeDetectionStrategy.OnPush
	#Cambiamos la estrategia y seleccionamos: OnPush
	#Y comprobamos que ahora cuando hacemos clic en un componente hijo de nivel 3
	#solo se está llamado a esa imagen específica.
	
#Vemos que solamente los cambios relacionados con ese componente
#afectan a los hijos del mismo
#Esta estrategia es particularmente útil si estamos trabajando 
#con una gran cantidad de componentes que a su vez tienen hijos,
#y puedan hacer que nuestra aplicación se vuelva ineficiente.
#En la medida de lo posible, si realizas algún timpo de lista
#que incluya componentes, te recomiendo que al menos evalúes la opción
#de incluir un control de cambios.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Inicialización de datos con @OnInit
-------------------------------------------------------------

#¿Qué diferencia hay entre un constructor y el evento ngOnInit?
constructor(){ }
ngOnInit(){ }

#En Angular ambos se ejecutan al inicio de un componente

#Pero vamos a ver un ejemplo de un caso concreto:
#En la clase del componente tenemos algo parecido a:

export class SinEstadoComponent implements OnInit {

// Sobre este componente se está inyectando un componente:
@Input() producto: Producto;

#Ahora en el constructor añadimos la siguiente línea
constructor() {
	this.accionCompra=`BUY FOR ${this.producto.precio}`;
}

#En la consola del navegador podemos ver el siguiente error:
#ERROR TypeError: Cannot read property 'precio' of undefined

#El constructor se va a ejecutar cuando se inicializa nuestra aplicación
#Y el objeto si nos ha sido inyectado pero 'precio' una de sus partes no está.

#¿Por qué puede estar pasando?
#El componente se crea en el momento en que se crea toda la apliación
#y en ese momento se ejecuta el constructor
#pero en ese momento aún no hemos desplagado la lista donde se están
#inyectando los valores propios de este objeto.

#Nosotros tenemos que esperar a que los componentes que van a gestionar
#este componente estén disponibles
#esto puede ocurrir rápidamente... o en un minuto... o en diez minutos
#no sabemos en qué momento va a ocurrir

#ngOnInit() y todos los eventos de Angular
#están relacionados con el ciclo de vida de un componente

#En el caso de ngOnInit() es lo primero que va a ocurrir
#en cuanto se inicialice el componente
#Un componente se inicializa en el momento en que nosotros lo llamamos
#o lo desplegamos dentro del DOM
#para que esto ocurra ya tenemos disponibles los valores del objeto

#Esto funcionará correctamente
ngOnInit() {
	this.accionCompra=`BUY FOR ${this.producto.precio}`;
}

#En general si necesitas inicializar valores que vengan de una fuente externa
#o que tengas que procesarlos a través de un proceso externo del componente
#casi siempre la mejor idea es utilizar el evento ngOnInit.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Limpieza de datos con @OnDestroy
-------------------------------------------------------------

#Hablemos del evento OnDestroy:

#En nuestra aplicación en el evento: ngOnInit tenemos:
ngOnInit() {
	this.tiendaSubscripcion = this.http
			.get("http://localhost:4200/assets/data/data.json")
			.subscribe((resultados:Array<Object>) => {
				this.modeloTienda = resultados;
			}
	});
}

#Básicamente en el momento en que se inicializa mi componente
#me pongo a consumir datos y con eso voy a desplegar la información
#se muestran el listado de productos que vienen del fichero json

#Hasta aquí todo está perfecto
#sin embargo, donde comienzan a aparcer los problemas
#y es muy importante tener en cuenta que todo componente tiene un ciclo de vida
#Así como nosotros estamos inicializando la conexión a internet 
#dentro de este componente con el evento ngOnInit
#si por alguna razón nosotros sacamos este componente de la aplicación
#al mantener una subscripción y por la naturaleza de las suscripciones
#que pueden ser muchísimas otras cosas, no necesariamente las suscripciones,
#cualquier elemento que nosotros creemos y se mantenga vivo,
#que se mantenga activo dentro de ngOnInit
#tenemos que destruirlo en su opuesto que es el evento ngOnDestroy

#Para implementar el evento que no viene por defecto hay que:
import { Component, OnInit, ViewChild, OnDestroy } from "@angular/core";

export class ConEstadoComponent implements OnInit, OnDestroy {

#El evento ngOnDestroy se va a ejecutar siempre que cerremos un componente:
+Cuando cerremos la navegación
+Cuando ejectamos algún tipo de lógia que destruya el componente
+Algo que haga que salga del DOM

#Hay muchas situaciones dentro de Angular que puede invocar un componente
#a ser destruído.
#Si tenemos cualquier elemento que permanezca activo en el ngOnInit
#vamos a destruirlo en el evento ngOnDestroy.

#De esta forma no solo vamos a remover nuestro componente
#sino todas las llamadas y todos los punteros de memoria que esté ocupando.
ngOnDestroy() {
	this.tiendaSubscripcion.unsubscribe(); // Detiene la escucha de la subscripción a ese enlace web
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Detección de cambios con @OnChanges
-------------------------------------------------------------

#Veremos cómo tener un control aún mayor sobre los cambios
#que realizamos dentro de los valores de nuestra apliación
#En la aplicación de ejemplo, donde estamos mostrando nuestros tres productos
#ha implementado un shopping cart
#donde puede añadir los elementos al carrito de compra con un botón de añadir
#y donde puede sacarlos del carrito de compra con un botón de quitar

#Para la implementación del Shopping cart ha añadido un nuevo componente:
ng generate component shopping-cart-status

#1 En la clase del componente ha añadido:
export class ShoppingCartStatusComponent implements OnInit {

	@Input() precio:number;
	@Input() modeloDeTienda:Array<Producto>;

	@Output() pagar:EventEmitter<null> = new EventEmitter();

	constructor() { }

	ngOnInit() { }

	realizarPago() {
		this.pagar.emit();
	}

}

#2 En la plantilla del componente: con-estado, añadimos el componente:

<app-shopping-cart-status></app-shopping-cart-status>
<app-alerta-confirmacion [cantidad]="precioTotal"></app-alerta-confirmacion>

#3 Añadimos los inputs en la etiqueta del componente,
con los objetos que nos inyectará en nuestro componente: shopping-cart-status
el componente padre con-estado:

<app-shopping-cart-status 	
							#Nos inyecta el precio total de los productos añadidos al carrito
							[precio]="precioTotal" 
							#Nos inyecta un array con los productos añadadidos al carrito
							[modeloDeTienda]="modeloTienda.tiendaItems"
							#Añadimos un evento que nos va a permitir hacer el pago:
							(pagar)="onPagar()">
</app-shopping-cart-status>

#Podemos detectar los cambios pero nos vamos a proponer la siguiente implementación
#por una funcionalidad que nos ha pedido el cliente, podremos añadir productos
#al carrito pero cuando el usuario quite algún producto del carrito tendremos
#que mostrarle un aviso.
#Así que tenemos que rastrear que el usuario no saque productos del shopping cart

#Vamos a añadir un nuevo evento de Angular que se llama: onChanges()

#Este evento detecta cuando hay cambios 
#Un punto muy importante sobre la implementación del evento onChanges()
#es que solo funciona dentro de componentes hijos.

#¿Por qué? Porque lo que vamos a rastrear son los cambios, changes,
#que se realicen dentro de los elementos en este caso, los inputs
#O sea, si precio o modelo tienen un cambio nosotros lo vamos a detectar
#y vamos a poder reaccionar acorde a estos cambios

#Para implementar el evento onChanges(), añdimos:
import { Component, OnInit, OnChanges, Input, Output, EventEmitter } from "@angular/core";

export class ShoppingCartStatusComponent implements OnInit, OnChanges {

#Recibimos como parámetro un tipo específico porque recibimos valores específicos
ngOnChanges(cambios:SimpleChanges) {
	#De momento para ver lo que recibimos:
	console.log(cambios);
}

#Al añadir un producto al carrito en la consola se muestra:
{precio:SimpleChange}
precio: SimpleChange
	currentValue:20
	firstChange:false
	previousValue:undefined
	
#Añadimos otro producto al carrito en la consola se muestra:
{precio:SimpleChange}
precio: SimpleChange
	currentValue:53
	firstChange:false
	previousValue:20
	
#Con este evento podemos llevar un control de los diferentes cambios
#Terminamos la implementación del evento con la petición funcional:

#Si el precio actual es menor que el precio anterior, es porque ha sacado
#un producto del carrito y le mostramos un mensaje al usuario:

ngOnChanges(cambios:SimpleChanges){
	if(cambios.precio.currentValue < cambios.precio.previousValue) {
		alert("¿Seguro que deseas sacar items?");
	}
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Detección de cambios con @DoCheck
-------------------------------------------------------------

#En esta lección vamos a ver un tipo de evento que se activa
#cuando hacemos cambios dentro del DOM.

#En la clase del componente ShoppingCartStatusComponent
#vamos a añadir un nuevo evento @DoCheck

import { Component, ..., Input, Output, ..., OnInit, DoCheck } from "@angular/core";

export class ShoppingCartStatusComponent implements OnInit, DoCheck {
... ... ...

ngDoCheck() { 
	console.log("DoCheck activado!");
}

#DoCheck es un evento que es parte del ciclo de vida de un componente 
#y en este caso se activa cada vez que realizamos un cambio en el DOM.

#En el caso de DoCheck lo que hace es que realizamos un chequeo
#una revisión, cada vez que se modifica el DOM.
#Esto incluye añadir un elemento al shopping-cart
#y que se muestre en el listado de productos comprados
#o también en el caso de que hagamos clic
#sobre el botón de comprar BUY NOW y se muestra la ventana emergente
#y como se muestra dentro del DOM, lo afecta, ngDoCheck se activa.

#Este tipo de evento es particularmente útil cuando necesitamos
#estar rastreando todo lo que ocurre en pantala.
#Un problema a tener en cuenta si decidimos utilizar este evento
#es que este evento se va activar muchas veces 
#y tendremos un coste de rendimiento


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Capturar el evento clic del mouse
-------------------------------------------------------------

#En esta lección vamos a ver cómo interactuar con el ratón.
#Vamos a la plantilla del componente sin-estado.component.html

#Queremos añadir un menú contextual con información extra para
#uno de los productos mostrados, añadimos:
<div class="contextual" [ngClass]="{ invisible: menuVisible }" >
	{{ producto.titulo }}
	{{ producto.precio | currency }}	
</div>

#Por defecto, se visualiza el título y el precio
#pero queremos que cuando se haga clic sobre el producto se oculte
#utilizando el class invisible, a través de la variable menuVisible

#Hablando un poco sobre cuál es la sintaxis general
#de todos los eventos en Angular, que es bastante consistente.
#Siempre va a ser, dentro de una etiqueta por ejemplo un div
#vamos a poner entre paréntesis el nombre del evento que queremos capturar.
#y luego vamos a poner que es igual a el método que queremos que se ejecute
#y que sea llamado en el momento en que ese evento se active.

#Para el ejemplo que estamos realizando, en el div del producto mostrado, tendremos:
<div class="is-one-quarter" 
	(contextmenu)="onRightClick()"
	(click)="onRegularClick()" >

#En la clase del componente sin-estado.component.ts, también añadimos:
private menuVisible: boolean;

onRegularClick() {
	this.menuVisible = true; // Esto activa la condicional y se oculta el div
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Capturar el clic derecho del ratón
-------------------------------------------------------------

#Ahora vamos a cambiar el comportamiento de nuestra aplicación de ejemplo
#para que se muestre el div con el título y el precio
#cuando haga clic con el botón derecho del ratón

#Cambiamos en el css, el estilo de .contextual a:
display:none; // Para que no se muestre

#Y en la plantilla cambiamos la clase invisible por visible:
<div class="contextual" [ngClass]="{ visible: menuVisible }" >
	{{ producto.titulo }}
	{{ producto.precio | currency }}	
</div>

#Ahora vamos a capturar el evento del clic derecho, 
#el evento que lo hace es: contextmenu:
<div class="is-one-quarter" 
	(contextmenu)="onRightClick()"

#En la clase del componente sin-estado.component.ts dejamos:
onRegularClick() { this.menuVisible = false; }
onRightClick() 	 { this.menuVisible = true;  }

#Ahora por defecto cuando entramos el div contextual no aparece
#Y al hacer clic con el botón derecho del ratón se muestra el div contextual, 
#pero también se muestra el menú contextual del navegador y no queda bien
#para solucionarlo, 
#debemos evitar que se activen las reacciones por defecto del sistema
#Añadimos: return false;
onRightClick() { 
	this.menuVisible = true;
	// Esto detiene la ejecución regular de este evento
	// que sería finalmente mostrar el menú contextual
	return false; 
}

#Con el clic regular, se cambia el estado de la variable
#y el valor de la clase y por tanto se oculta el div contextual
#con el título y el precio.


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Captura de eventos del teclado con Angular
-------------------------------------------------------------

#Vamos a modificar nuestro componente de shopping-cart-status
#para escuchar eventos de teclado:

#Vamos a la plantilla del componente shopping-cart-status.component.html
#Y añadimos un 
<input type="text"

#Ahora vamos a enlazar este input type="text"
#con un listener o un evento de Angular
#para poder escucharlo dentro de nuestro código
#y para eso vamos a utilizar la sintaxis general que tiene Angular
#que es entre paréntesis poner el evento que queremos escuchar
#Específicamente, vamos a escuchar un evento llamado (keydown)
#y vamos a relacionarlo con un método, en este caso, se va a llamar onTeclado()
#También vamos a necesitar inyectar información 
#que es la información que nos está llegando del evento de teclado
#hay varios datos que nos van a llegar desde allí.
#Así que vamos a utilizar un objeto especial llamado (Event)
#que nos muestra toda la información que llega desde este evento
#que en este caso es keydown. Tendremos:
<input type="text" (keydown)="onTeclado($event)" />

#Vamos a la clase del componente shopping-cart-status.component.ts
#donde implementamos el método: onTeclado

onTeclado(_evento) {
	console.log(_evento);
}

#Ahora cada vez que escribimos en el input type"text"
#y pulsamos una letra se muestra el evento en la consola
#Algo así:
> KeyboardEvent {....
	code: "KeyA"
	... ... ... ..

#Entonces, por ejemplo si nosotros queremos detectar la tecla Enter
#Al pulsar Enter dentro del input de texto se muestra:
> KeyboardEvent {....
	code: "Enter"
	keyCode: 13
	... ... ... ..

#Entonces lo implementamos en el método:
onTeclado(_evento) {
	if(_evento.code==="Enter") {
		this.realizarPago();
	}
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Captura global de eventos de teclado
-------------------------------------------------------------

#En el ejemplo anterior nuestra escucha del evento de que el usuario
#pulse la tecla Enter estaba limitada al input de texto.

#Ahora nos gustaría tener un control global para que cuando el usuario
#quiera realizar la compra y se le muestre la ventana de pago
#no tenga necesariamente el cursor en el input
#sino que sea una escucha global en todo el formulario.

#Para nuestro ejemplo, empezamos borramos el input anterior
#de la plantilla de nuestro componente shopping-cart-status.component.html
<input type="text" (keydown)="onTeclado($event)" />

#Lo que vamos a hacer es que vamos a escuchar los eventos del teclado
#a través de Javascript.
#Vamos a la clase del componente shopping-cart-status.component.ts
#En el evento ngOnInit
#este evento se va activar en el momento en que mi componente,
#específicamente, en este caso, el shopping cart se inicialice;
#Así que dentro de este evento voy a incluir una implementación
#que va a ser activarEventoTeclado:

Vamos a escuchar un evento, keypress 
#Así que cada vez que el usuario presione una tecla, lo vamos a escuchar
#es una escucha global
#Le pasamos el evento como parámetro a nuestra anterior método
#por tanto ahora funciona igual que antes pero la escucha es global

ngOnInit() {
	this.activarEventoTeclado();
}

activarEventoTeclado(){
	document.addEventListener("keypress", (evento)=>{
		this.onTeclado(evento);
	})
}

onTeclado(_evento) {
	if(_evento.code==="Enter") {
		this.realizarPago();
	}
}


@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
4. Eventos y ciclo de vida en Angular
+Prevenir fugas de memoria por eventos globales
-------------------------------------------------------------

#En esta lección vamos a ver como prevenir posibles fugas de memoria
#y efectos indeseados en la escucha de eventos globales

#Con el ejemplo anterior tenemos los siguientes problemas identificados
#al utilizar document. estamos escuchando en los eventos del todo el navegador
#esta escucha va más allá del ciclo de vida de la aplicación
#y más allá del ciclo de vida del componente
#por tanto aunque cierre la pestaña la escucha de eventos keypress persiste

#Para evitar este problema, buscamos el evento ngOnDestroy
#este evento se activa cuando cerramos o destruimos un componente

import { Component, ..., OnDestroy } from "@angular/core";

export class ShoppingCartStatusComponent implements OnInit, OnChanges, OnDestroy {

#Es absolútamente crítico que lo incluyamos
#cada vez que hagamos este tipo de llamadas globales
ngOnDestroy(){
	document.removeEventListener("keypress",this.onTeclado);
}




